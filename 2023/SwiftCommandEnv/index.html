<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.yigegongjiang.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.1","exturl":true,"sidebar":{"position":"left","width":140,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"text":"Light Mode (Better for light mode to discuss, base github, cannot commen can email me)","order":-2},"utterances":{"text":"Dark Mode","order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="2024.01.06 更：欢迎查阅 Swift 开发的文本纠错命令行工具。  不推荐使用 Swift 写脚本，和 Python 比起来，该生态链相对匮乏，开发耗时会增加很多。但对于偏 Swift 的同学来说，这也的确是更可控和方便维护的方式之一。尤其对于公司内部工具，有问题可以更快的找到原因并处理，不至于手忙脚乱。 相对于 Python 环境丰富的基建资源，使用 Swift 做脚本开发的优点在于">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 脚本开发环境搭建">
<meta property="og:url" content="https://www.yigegongjiang.com/2023/SwiftCommandEnv/index.html">
<meta property="og:site_name" content="一个工匠">
<meta property="og:description" content="2024.01.06 更：欢迎查阅 Swift 开发的文本纠错命令行工具。  不推荐使用 Swift 写脚本，和 Python 比起来，该生态链相对匮乏，开发耗时会增加很多。但对于偏 Swift 的同学来说，这也的确是更可控和方便维护的方式之一。尤其对于公司内部工具，有问题可以更快的找到原因并处理，不至于手忙脚乱。 相对于 Python 环境丰富的基建资源，使用 Swift 做脚本开发的优点在于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312131859591.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312131859592.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312132012823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312132019237.png">
<meta property="article:published_time" content="2023-12-13T03:27:00.000Z">
<meta property="article:author" content="海驴">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Swift三方源码系列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312131859591.png">


<link rel="canonical" href="https://www.yigegongjiang.com/2023/SwiftCommandEnv/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.yigegongjiang.com/2023/SwiftCommandEnv/","path":"2023/SwiftCommandEnv/","title":"Swift 脚本开发环境搭建"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Swift 脚本开发环境搭建 | 一个工匠</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8CTEWJ02QX"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-8CTEWJ02QX","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="一个工匠" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="一个工匠" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">一个工匠</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags<span class="badge">13</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives<span class="badge">85</span></a></li><li class="menu-item menu-item-日本指北"><a href="/japan/" rel="section">日本指北</a></li><li class="menu-item menu-item-时间舟"><a href="/categories/%E6%97%B6%E9%97%B4%E8%88%9F/" rel="section">时间舟</a></li><li class="menu-item menu-item-source"><a href="/openSource" rel="section">Source</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section">About</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section">RSS</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-Swift-%E7%94%9F%E6%80%81"><span class="nav-number">1.</span> <span class="nav-text">0x01 Swift 生态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#playground-repl"><span class="nav-number">1.1.</span> <span class="nav-text">playground &amp; repl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Package"><span class="nav-number">1.2.</span> <span class="nav-text">!!! Package</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Package-%E6%8F%92%E4%BB%B6"><span class="nav-number">1.2.1.</span> <span class="nav-text">Package 插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">生态小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">命令行开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">命令行输入参数解析自动化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%96%84%E7%94%A8-Xcode-IDE-%E7%9A%84%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">2.2.</span> <span class="nav-text">善用 Xcode IDE 的调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%84%9A%E6%9C%AC"><span class="nav-number">2.2.1.</span> <span class="nav-text">插入脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">插入参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">2.3.</span> <span class="nav-text">进度条的输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%881%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">方案 1（不建议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%882%EF%BC%88%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">方案 2（建议）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%AD%89%E5%BE%85"><span class="nav-number">2.4.</span> <span class="nav-text">异步等待</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">2.5.</span> <span class="nav-text">系统命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B0%8F%E7%BB%93"><span class="nav-number">2.6.</span> <span class="nav-text">命令行小结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="海驴"
      src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202309220309178.webp">
  <p class="site-author-name" itemprop="name">海驴</p>
  <div class="site-description" itemprop="description">时间，真的不多了。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9oYWlfbHZf" title="https:&#x2F;&#x2F;twitter.com&#x2F;hai_lv_">X(Twitter)</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.yigegongjiang.com/2023/SwiftCommandEnv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202309220309178.webp">
      <meta itemprop="name" content="海驴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个工匠">
      <meta itemprop="description" content="时间，真的不多了。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Swift 脚本开发环境搭建 | 一个工匠">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift 脚本开发环境搭建
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-13 11:27:00" itemprop="dateCreated datePublished" datetime="2023-12-13T11:27:00+08:00">2023-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>2024.01.06 更：欢迎查阅 Swift 开发的<a href="https://www.yigegongjiang.com/2024/SwiftZhTextCorrect/">文本纠错命令行工具</a>。</p>
</blockquote>
<p>不推荐使用 Swift 写脚本，和 Python 比起来，该生态链相对匮乏，开发耗时会增加很多。<br>但对于偏 Swift 的同学来说，这也的确是更可控和方便维护的方式之一。尤其对于公司内部工具，有问题可以更快的找到原因并处理，不至于手忙脚乱。</p>
<p>相对于 Python 环境丰富的基建资源，使用 Swift 做脚本开发的优点在于<strong>生态的一致性</strong>。<br>苹果官方抹平了 脚本开发 和 应用开发 的界限，即 开发环境、三方库导入和使用 (苹果自身的开源库 / 三方库)、系统平台 api (存储、网络、协程、并发等，UI api 除外) 等，均表现一致。<br>可以像应用开发的流程一样，进行脚本命令行的开发。</p>
<span id="more"></span>

<h1 id="0x01-Swift-生态"><a href="#0x01-Swift-生态" class="headerlink" title="0x01 Swift 生态"></a>0x01 Swift 生态</h1><p>一言两语，先概要描述下 Swift 目前的生态，以明确脚本开发所处的位置。</p>
<p>Swift 做为苹果大力推出的 iOS/Mac 多平台应用开发语言，目前广泛用于开发 app (ipa/dmg)。做为古老的 Objective-C 替代者，基本上对接了 OC 里面所有的 Api，可以直接调用。这对新语言的铺广有很大好处，使用成本有非常大的降低。<br>但 Swift 也抛弃了 OC 的消息传递机制，使得 patch 等能力很难实现。这也是大公司不愿意迁移的原因，在苹果不允许热更新之后，它们都耗费大精力维护一套不公开的 patch 能力，以在紧急时刻做补救。</p>
<p>Swift 做为后浪，完全集百家之长，也躲过了这些年高级语言已知的不完美，这是相当优秀的点。<br>至目前 (23 年底)，已经对范型、协程、并发等高级场景做了完备的支持。<br>尤其值得关注的是发源地 app 开发，Swift 提供了 SwiftUI 做为原始 UIkit/AppKit 的替代，这是目前非常跟随潮流的 UI 基础建设。</p>
<p>Swift 以跨平台为前提，也同样可以做服务端开发、输出命令行可执行文件等。但刚才提到的 UI 能力并不能服务于此，毕竟这是不需要 UI 能力的。</p>
<h2 id="playground-repl"><a href="#playground-repl" class="headerlink" title="playground &amp; repl"></a>playground &amp; repl</h2><p>对于学习 Swift 来说，playground 是一个不错的学习乐园。<br>playground 有两种，一种是 iPad 和 Mac 上都适配的 app，名字叫 <span class="exturl" data-url="aHR0cHM6Ly9hcHBzLmFwcGxlLmNvbS91cy9hcHAvc3dpZnQtcGxheWdyb3VuZHMvaWQxNDk2ODMzMTU2P210PTEy">Swift Playground</span>，通过 SwiftUI 开发项目，可以直接上 App Store。<br>还有一种是通过 xcode - new - playground 生成的后缀名为 <strong>.playground</strong> 的项目，主要用于测试一些代码。</p>
<p>第一种完全是鸡肋，我是这么认为。第二种，也倾向于鸡肋，用处不大（更多用于调试，可 xcode 里创建一个项目已经足够方便）。<br>这里建议，<strong>对于 Swift 研发同学来说，可以不用看 playground 了</strong>，这样可以避免理解不少概念，如 <code>PlaygroundSupport</code>、<code>Sources</code>、<code>Resources</code>、<code>多target分隔</code>等。<br>这些概念和实践，在研发历程上，基本是无用的。凭空增加了 Swift 的知识点复杂度。</p>
<p>和 playground 类似的，还有 repl，即在终端通过 <code>swift repl</code> 进入的交互式编程环境。很多语言都带有这个环境，快速调试无可厚非，但我还是给予鸡肋的标签。</p>
<p>当然，对于其他语言使用者，仅仅希望了解一下 Swift，playground 和 repl 都是不错的选择，尤其 repl。可以不用理解完整项目里面的很多概念，如 AppDelegate/AppScene/Navigation 等。</p>
<h2 id="Package"><a href="#Package" class="headerlink" title="!!! Package"></a>!!! Package</h2><p>Apple 在 Swift 出来的时候，提出了 SPM (Swift Package Manager) 概念，和 Cocoapods 一致，做为三方库的管理工具。其中描述文件就是 <code>Package.swift</code> 文件。<br>后期，SPM 扩展了能力，和 <code>.xcodeproj</code> 处于同样的地位。通过对 <code>Package.swift</code> 文件进行配置，Package 所在的文件夹可以做为 <code>动静态库</code> 被 workspace 管理，也可以设置多个 Target 进行依赖控制，还可以引入三方库，甚至可以直接配置成可执行文件和插件 (如代码格式化等)。<br>这使得对 Package 的理解复杂度增加。</p>
<p>一开始，Package 对 target、exec 的支持，是通过 <code>swift package generate-xcodeproj</code> 命令，生成辅助 <code>.xcodeproj</code> 文件来完成的。后期 Swift 升级，删除了这个命令，完全通过 <code>Package.swift</code> 配置文件来完成了。<br>这一改变，应该是为 <code>Swift Playground</code> 这个 app 做的。如上面说到的，这个 app 可以独立制作项目并上传 App Store，通过该 app 生成的项目文件是 <code>.swiftpm</code>，不用理解 <code>.xcodeproj - build setting</code> 等众多概念，多 target、三方库 均通过 <code>Package.swift</code> 配置。<br>可能因为这个原因，提升了 <code>Package.swift</code> 的级别，和 <code>.xoceproj</code> 处于同样的地位。</p>
<p>所以，对 <code>.xcodeproj</code> 熟悉的同学，不用刻意理解 <code>Package.swift</code> 里面的诸多配置，这些配置仅仅是对 <code>.xcodeproj</code> 配置的迁移。用到哪里，查一下资料即可。<br>下面给示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// swift-tools-version: 5.9</span><br><span class="line">// The swift-tools-version declares the minimum version of Swift required to build this package.</span><br><span class="line"></span><br><span class="line">import PackageDescription</span><br><span class="line"></span><br><span class="line">let package = Package(</span><br><span class="line">  name: "pcd", // 该 Package 的名字，如果是动静态库，可以理解为 pcd.framework。外部通过 `import pcd` 来引入</span><br><span class="line">  products: [ // Build 和 Archive 输出的产物</span><br><span class="line">    .executable(name: "pcd", targets: ["pcd"]), // 输出可执行文件(脚本工具等)</span><br><span class="line">    .library(name: "pcdCore", type: .dynamic, targets: ["pcdCore"]) // 输出动静态库</span><br><span class="line">  ],</span><br><span class="line">  dependencies: [ // 三方依赖。若通过 path 进行本地依赖，则可在当前工程直接编辑其内容，便于开发联调。同 cocoapods。</span><br><span class="line">    .package(url: "https://github.com/apple/swift-argument-parser.git", from: "1.2.0"),</span><br><span class="line">    .package(url: "../Progress.swift", branch: "master"),</span><br><span class="line">    .package(path: "/Users/gebiwanger/Downloads/swift_public_project/SwiftShell") // 本地依赖，可在当前工程直接修改库代码</span><br><span class="line">  ],</span><br><span class="line">  targets: [</span><br><span class="line">    .target(</span><br><span class="line">      name: "pcdCore" // 同 `.xcodeproj` 里面的 target 设置，这里设置一个动静态库</span><br><span class="line">    ),</span><br><span class="line">    .executableTarget( // 本身是 Target，同 `.xcodeproj` 主项目，可通过 Archive 进行打包（产物类似 a.out，非 app/ipa/dmg）</span><br><span class="line">      name: "pcd",</span><br><span class="line">      dependencies: [ // 多 target 依赖。可以依赖当前项目的 target，也可以依赖三方库(同 Cocoapods)。注意，三方库一定需要依赖，才能在当前项目中被使用(Pods 也是一样，只是Pods工具帮忙做了)。</span><br><span class="line">        .target(name: "pcdCore"),</span><br><span class="line">        .product(name: "ArgumentParser", package: "swift-argument-parser"),</span><br><span class="line">        .product(name: "Progress", package: "Progress.swift"),</span><br><span class="line">        .product(name: "SwiftShell", package: "SwiftShell"),</span><br><span class="line">      ]</span><br><span class="line">    ),</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312131859591.png" width="30%">

<p>上图是单独的 Package 项目示例，可以通过 Xcode 进行和 <code>.xcodeproj</code> 一致的调试。</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312131859592.png" width="30%">

<p>从上图可以验证，Package 项目，具有和 <code>.xcodeproj</code> 一致的功能，概念层级是和 <code>.xcodeproj</code> 一致的。</p>
<p>至此，Package 的概念和使用，基本已经介绍完毕，都是旧瓶装新酒。</p>
<h3 id="Package-插件"><a href="#Package-插件" class="headerlink" title="Package 插件"></a>Package 插件</h3><p>除此之外，还想介绍一个 Package 特有的能力，就是<strong>插件</strong>。插件是一个可执行程序，可以本地运行或做为三方库接入，但不允许上架包引用，仅允许做本地调试。（不排除后期会开放 App Store 的能力）<br>对于目前 Xcode 支持的扩展，有些能力是可以通过插件来完成的，比如代码格式化、代码转换等。<br>插件的整体开发过程，和 动静态库 / 可执行文件 的开发流程基本一致，通过下面的配置进行区分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let package = Package(</span><br><span class="line">  products: [ // 新增了 plugin 产物</span><br><span class="line">    .plugin(name: "FormatSwift", targets: ["FormatSwift"]),</span><br><span class="line">  ],</span><br><span class="line">  targets: [</span><br><span class="line">    .plugin( // 新增了 plugin Target</span><br><span class="line">      name: "FormatSwift",</span><br><span class="line">      capability: .command( // 权限控制，支持读取/写入项目文件。在代码格式化的时候需要该权限</span><br><span class="line">        intent: .custom(</span><br><span class="line">          verb: "format",</span><br><span class="line">          description: "Formats Swift source files according to the Airbnb Swift Style Guide"),</span><br><span class="line">        permissions: [</span><br><span class="line">          .writeToPackageDirectory(reason: "Format Swift source files"),</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    .executableTarget( // 可以有 exec target 或者动静态库 target，便于调试或者被 plugin 依赖。</span><br><span class="line">      name: "AirbnbSwiftFormatTool",</span><br><span class="line">    ),</span><br><span class="line">  ])</span><br></pre></td></tr></tbody></table></figure>
<p>通过 Archive 打包出的产物，可以做为可执行文件单独执行。其他项目也可以引入插件模块，右键主工程就可以看到插件的运行选项。</p>
<p>插件这一块的需求并不大，这里也不做更多介绍了。参考项目有 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9zd2lmdA==">airbnb-swift-format</span> ，有需要可以查阅更多相关资料。</p>
<h2 id="生态小结"><a href="#生态小结" class="headerlink" title="生态小结"></a>生态小结</h2><p>至此，Swift 的开发生态介绍的差不多了，整体和 Xcode IDE 依旧有非常深的绑定。<br>当然也可以通过 <code>swift xxx</code> 等命令行进行开发和调试，但对于 Mac 平台的开发人员来说，这完全是多此一举。</p>
<p>除此之外，前面也说到 Swift 是一门非常新也非常优秀的高级语言，其中的 协程、并发、多线程 等能力，也都是需要单独学习和掌握的。这属于语言本身，在环境篇就不再过多介绍。</p>
<h1 id="命令行开发"><a href="#命令行开发" class="headerlink" title="命令行开发"></a>命令行开发</h1><p>这里进入核心环节，即通过 Swift 进行命令行开发的环境。<br>其实上面的环境篇，已经介绍了大部分命令行开发所需要的前期准备，如工程的搭建、项目依赖的设定等。</p>
<p>在 Objective-C 时期，也可以通过 Xcode 进行 <code>Command line</code> 的开发，通过 <code>new - project - macOS - Command Line Tool</code> 既可以建立一个工程，Archive 后即可输出可执行文件。<br>但 OC 终究不是为命令行而生的，有很多局限性和短板。这也导致十几年来一直都有的这个功能，更多被用于 C/C++ 的调试入口。</p>
<p>目前 Swift 做命令行开发，依旧可以走之前的流程建立一个 <code>.xcodeproj</code> 工程进行开发，区别点是语言选项上，勾选 Swift 即可。<br>同时，上面的流程也显得有些落伍，毕竟如上面介绍，Package 具有和 <code>.xcodeproj</code> 同样的层级定义，我们可以通过 Package 来创建可执行程序。<br>这样的一个明显的好处，是不用理解 AppleId / Build Setting 等复杂的配置。显然，做为一个通用的命令行工具，我们可以提交到 brew 或者随意分发给有需要的朋友，哪里还需要 AppleId 开发者账号呢？</p>
<p>Swift Package 命令行的项目创建 / 编译 / 调试 / 运行，可以通过 <code>swift xx</code> 命令行操作。有了 Xcode 这个高度集成的工具，显然不用如此费力。<br>创建项目的流程为：new - Package - macOS - Command Line Tool / Executable。<br>这样创建的工程就是 Package 工程，而不再是 <code>.xcodeproj</code> 工程。<code>Command Line Tool</code> 和 <code>Executable</code> 基本没有区别，前者多了一个 <code>ArgumentParser</code> 这个 apple 自带的库依赖。也正因为这个依赖，推荐使用前者，这在命令行开发的过程中会方便很多。</p>
<h2 id="命令行输入参数解析自动化"><a href="#命令行输入参数解析自动化" class="headerlink" title="命令行输入参数解析自动化"></a>命令行输入参数解析自动化</h2><p>可以通过 CommandLine 模块做参数解析，提供了 argc 和 arguments 等 api，可以获取用户在执行命令的时候携带的参数。</p>
<p>不过后面，Apple 提供了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWFyZ3VtZW50LXBhcnNlcg==">ArgumentParser</span> 模块，这是可以快速搭建 命令行参数定义 的框架，比如命令中需要用户携带文件路径，通过 <code>@Argument(help: "Please Input File Path.") var path: String</code> 这样的定义，就可以指定用户一定要传文件路径并会被赋值到 path 变量中。如果用户输入错误或者使用 <code>xx --help</code>，<code>Please Input File Path.</code> 这个注释也会输出到命令行中以提醒用户。<br>当然，<code>ArgumentParser</code> 模块的能力远远不止这些。但可以看出来，<code>ArgumentParser</code> 定义了一套命令行参数的标准，开发人员不用再通过 <code>CommandLine</code> 模块调用 api 进行解析。<br>更重要的是，<code>ArgumentParser</code> 提供了一套命令行开发的流程框架，这可以通过阅读官方的示例文档进行学习。</p>
<p>前面说到 <code>Command Line Tool</code> 和 <code>Executable</code> 两种方式创建的项目相比，前者多了 <code>ArgumentParser</code> 引入。这也是推荐使用前者的原因。</p>
<p>当然，对于 <code>ArgumentParser</code> 的使用，可以参考官方的示例 (Examples 文件夹)。也可以查阅更多相关资料。</p>
<h2 id="善用-Xcode-IDE-的调试技巧"><a href="#善用-Xcode-IDE-的调试技巧" class="headerlink" title="善用 Xcode IDE 的调试技巧"></a>善用 Xcode IDE 的调试技巧</h2><p>命令行开发过程中，一样需要断点调试，同时也需要真实环境下调试。这两者往往是同时进行的。<br>这里有一个小技巧，即通过在 Xcode Build 过程中插入脚本，和 Xcode Run 过程中插入参数，来完成快速的开发调试。</p>
<h3 id="插入脚本"><a href="#插入脚本" class="headerlink" title="插入脚本"></a>插入脚本</h3><p>可以在 Scheme - Build - Post actions 中嵌入 bash 脚本，从而将编译好的可执行文件自动复制到 <code>/usr/local/bin</code> 目录，这样写完代码 Build 完成后，既可以在终端中进行真实场景下的调试和测试。<br>值得注意的是，一定要将 <code>Provide build settings from</code> 选择为当前编译的项目，这样才可以使用 Xcode 预定义的脚本变量。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp "$TARGET_BUILD_DIR/pcd" "/usr/local/bin"</span><br><span class="line">echo "move $TARGET_BUILD_DIR/pcd to /usr/local/bin success."</span><br></pre></td></tr></tbody></table></figure>

<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312132012823.png" width="30%">

<h3 id="插入参数"><a href="#插入参数" class="headerlink" title="插入参数"></a>插入参数</h3><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202312132019237.png" width="30%">

<h2 id="进度条的输出"><a href="#进度条的输出" class="headerlink" title="进度条的输出"></a>进度条的输出</h2><p>进度条输出，和以往的 print 不太一样。因为 print 是叠加的，下一条输出和上一条会间隔一行。<br>而进度条的输出，是重写上一行。<br>这里需要一些小技巧，即：不换行更新上一次的输出结果</p>
<h3 id="方案1（不建议）"><a href="#方案1（不建议）" class="headerlink" title="方案1（不建议）"></a>方案 1（不建议）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while true:</span><br><span class="line">  print("Count: \(counter)", terminator: "\r")</span><br><span class="line">  fflush(stdout)</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>\r</code> 将当前输出的 seek 切换到当前输出行的行首。这样下一次输出的时候，就从当前行的行首输出，对上一次的输出进行覆盖。<br>因为没有回车符了，而终端是识别到回车符，然后将回车符之前缓冲区的内容一次性进行输出的。<br>所以需要使用 <code>fflush(stdout)</code> 进行强制缓冲区刷新，即强制输出。</p>
<p>但上面介绍的这种方式有个缺点，即覆盖内容只能按照字节长度进行覆盖。如上一次输出是 <code>abc</code>，下一次输出是 <code>12</code>，此时显示的内容是 <code>12c</code>。<br>这在进度条中不容易出现，但面对复杂场景显然是不行的。</p>
<h3 id="方案2（建议）"><a href="#方案2（建议）" class="headerlink" title="方案2（建议）"></a>方案 2（建议）</h3><p>这里推荐第二种方式，可以有效解决这个问题：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while true:</span><br><span class="line">  print("\u{1B}[1A\u{1B}[K\(progressBar.value)")</span><br></pre></td></tr></tbody></table></figure>
<p>输出文本加上 <code>\u{1B}[1A\u{1B}[K</code> 前缀即可。技术方案和上面是一样的，但可以规避上面的问题。<br>不过这里有个小 case，即单纯这样使用，会发现第一次输出的时候，整个命令行已有的内容都消失了。所以还需要加一个补丁：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// the cursor is moved up before printing the progress bar.</span><br><span class="line">// have to move the cursor down one line initially.</span><br><span class="line">print("")</span><br><span class="line">while true:</span><br><span class="line">  print("\u{1B}[1A\u{1B}[K\(progressBar.value)")</span><br></pre></td></tr></tbody></table></figure>

<p>在进行输出的时候，先输出一个空内容，这样就不会有任何异常了。</p>
<h2 id="异步等待"><a href="#异步等待" class="headerlink" title="异步等待"></a>异步等待</h2><p>命令行执行完毕，进程就销毁了。如果需要进行网络请求等异步操作，就需要特别处理，以等待异步请求的结果。</p>
<p>这里可以通过 runloop 将当前线程永久激活，然后通过 exit 强制退出。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async {</span><br><span class="line">  ...</span><br><span class="line">  exit(0/-1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">RunLoop.current.run()</span><br></pre></td></tr></tbody></table></figure>

<p>显然，这不是一个好的方案，一来局限性很多。<br>在者，runloop 是 app/ipa/dmg 开发中的概念，虽然利用了 Swift api 完备性的优势，但在这里使用很不合适。</p>
<p>这里更好的解决方案是使用信号量：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let semaphore = DispatchSemaphore(value: 0)</span><br><span class="line">async {</span><br><span class="line">  ...</span><br><span class="line">  semaphore.signal()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">semaphore.wait()</span><br></pre></td></tr></tbody></table></figure>
<p>可以将信号量的操作，进行单独封装，后续需要 wait 的时候，只需要便捷的调用一些 api 即可。</p>
<p>当然，鉴于 GCD 强大的多线程管理能力，还可以使用 group 等方式，进行多个异步操作的并行操作等。</p>
<h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><p>当然，命令行开发过程中，不可避免需要使用到丰富的系统命令，如 <code>ls/grep</code> 等。<br>这可以通过 Process Api 来操作，但这里不做过多介绍，因为有强大的三方库可以使用。<br>详见：<a href="https://www.yigegongjiang.com/2023/SwiftSystemShell/">【Swift 三方源码 1】SwiftShell 高效的命令行工具</a></p>
<h2 id="命令行小结"><a href="#命令行小结" class="headerlink" title="命令行小结"></a>命令行小结</h2><p>以上，就是通过 Swift 做命令行开发中的一些概要和部分细节的地方了。<br>如最开始说到的那样，使用 Swift 开发命令行，除了 UIKit/AppKit/SwiftUI 这些 UI 属性不能使用之外，其他并没有太多的 api 限制。<br>甚至可以使用 UserDefault 存储，这样可以极大的简化用户的 cookie 等信息的保存。</p>
<p>除此之外，大概就是对 Swift 高效和美丽的使用了。<br>Swift 这门语言虽然上手容易，但美丽的使用并不简单。<br>巧妙的使用 enum、protocol、async、combine 等高级功能，并且不搞乱代码，就很优秀。</p>
<hr>
<p>什么都给了，又什么都没给。<br>什么都干了，又什么都没干。<br>什么都说了，又什么都没说。</p>
<p>放开了所有权限，又加上精细的卡口。</p>
<p>鸡和蛋的轮回，永不停息的魔咒。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Follow me by other channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/hai_lv_">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/hai_lv_tg">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="mailto:one.gongjiang@gmail.com">
            <span class="icon">
              <i class="fa fa-envelope"></i>
            </span>

            <span class="label">Email</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Swift/" rel="tag"># Swift</a>
              <a href="/tags/Swift%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/" rel="tag"># Swift三方源码系列</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/rime/" rel="prev" title="rime - 小鹤双拼">
                  <i class="fa fa-angle-left"></i> rime - 小鹤双拼
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/SwiftSystemShell/" rel="next" title="【Swift 三方源码 1】SwiftShell 高效的命令行工具">
                  【Swift 三方源码 1】SwiftShell 高效的命令行工具 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">Light Mode (Better for light mode to discuss, base github, cannot commen can email me)</a></li>
            <li class="tab"><a href="#comment-utterances">Dark Mode</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments utterances-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class=""></i>
    </span>
    <span class="author" itemprop="copyrightHolder">one.gongjiang艾特gmail.com 所有文章均为原创。我不介意任意形式的转载，但最好不要修改内容。因转载或者修改内容导致的任何问题，我均不负责。如果你真的担心版权，可邮联。评价需要外网，这是枷锁，也是照妖镜。</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.yigegongjiang.com/2023/SwiftCommandEnv/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yigegongjiang","repo":"yigegongjiang_discuss","client_id":"65bebc0a049450012bda","client_secret":"06004e7143dc59f263a8d1bd1893dcf66d6bb7ee","admin_user":"yigegongjiang","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"0e890d650bc84c0d13e8cccd6ae758ed"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"yigegongjiang/yigegongjiang_discuss","issue_term":"title","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
