<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.yigegongjiang.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.1","exturl":true,"sidebar":{"position":"left","width":140,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"text":"Light Mode (Better for light mode to discuss, base github, cannot commen can email me)","order":-2},"utterances":{"text":"Dark Mode","order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="最近本网站的 HTTPS SSL 证书过期了，于是去域名管理平台重新申请了一下。无意中通过 dig 发现，网站的 DNS 解析 IP 一直是 198.18.1.xxx 这些。因为我的域名是 CNAME 映射到 github 的，所以又 dig 了一下 github 对应的 ip，发现也是 198.18.1.xxx。从哪个角度来看，至少都有些问题。我用的 DNSPod 域名解析平台，dig 自定义域">
<meta property="og:type" content="article">
<meta property="og:title" content="网络代理是如何工作的(致敬Surge)">
<meta property="og:url" content="https://www.yigegongjiang.com/2023/for_surge/index.html">
<meta property="og:site_name" content="一个工匠">
<meta property="og:description" content="最近本网站的 HTTPS SSL 证书过期了，于是去域名管理平台重新申请了一下。无意中通过 dig 发现，网站的 DNS 解析 IP 一直是 198.18.1.xxx 这些。因为我的域名是 CNAME 映射到 github 的，所以又 dig 了一下 github 对应的 ip，发现也是 198.18.1.xxx。从哪个角度来看，至少都有些问题。我用的 DNSPod 域名解析平台，dig 自定义域">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304160218073.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161453816.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161543953.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161611321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161643722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161710350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161910996.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161929876.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161955165.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334647.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334490.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162344424.png">
<meta property="article:published_time" content="2023-04-16T08:43:00.000Z">
<meta property="article:author" content="隔壁王二">
<meta property="article:tag" content="计算机原理">
<meta property="article:tag" content="网络">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304160218073.png">


<link rel="canonical" href="https://www.yigegongjiang.com/2023/for_surge/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.yigegongjiang.com/2023/for_surge/","path":"2023/for_surge/","title":"网络代理是如何工作的(致敬Surge)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>网络代理是如何工作的(致敬Surge) | 一个工匠</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="一个工匠" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="一个工匠" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">一个工匠</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags<span class="badge">12</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives<span class="badge">70</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li><li class="menu-item menu-item-rss"><a href="/rss2.xml" rel="section"><i class="rss fa-fw"></i>Rss</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%B4%E6%95%AC-Surge"><span class="nav-number">1.</span> <span class="nav-text">致敬 Surge</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%9F%B3"><span class="nav-number">2.</span> <span class="nav-text">基石</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket"><span class="nav-number">2.1.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wireshark"><span class="nav-number">2.2.</span> <span class="nav-text">Wireshark</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86-%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">网络代理-系统代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http"><span class="nav-number">3.1.</span> <span class="nav-text">http</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https"><span class="nav-number">3.2.</span> <span class="nav-text">https</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socks5"><span class="nav-number">3.3.</span> <span class="nav-text">socks5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E9%BB%98%E8%AE%A4%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">终端默认为什么不走代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.4.1.</span> <span class="nav-text">POSIX 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E8%B5%B0%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86"><span class="nav-number">3.4.2.</span> <span class="nav-text">终端走系统代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86-%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1"><span class="nav-number">4.</span> <span class="nav-text">网络代理-虚拟网卡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Surge%E5%92%8CVPN%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">5.</span> <span class="nav-text">Surge和VPN的差异</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MitM"><span class="nav-number">6.</span> <span class="nav-text">MitM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DNS"><span class="nav-number">7.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOH-httpdns"><span class="nav-number">8.</span> <span class="nav-text">DOH(httpdns)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%BE"><span class="nav-number">9.</span> <span class="nav-text">尾</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隔壁王二"
      src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202301081602545.gif">
  <p class="site-author-name" itemprop="name">隔壁王二</p>
  <div class="site-description" itemprop="description">时间，真的不多了。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.yigegongjiang.com/2023/for_surge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202301081602545.gif">
      <meta itemprop="name" content="隔壁王二">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个工匠">
      <meta itemprop="description" content="时间，真的不多了。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="网络代理是如何工作的(致敬Surge) | 一个工匠">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络代理是如何工作的(致敬Surge)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-16 16:43:00" itemprop="dateCreated datePublished" datetime="2023-04-16T16:43:00+08:00">2023-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近本网站的 HTTPS SSL 证书过期了，于是去域名管理平台重新申请了一下。<br>无意中通过 dig 发现，网站的 DNS 解析 IP 一直是 <strong>198.18.1.xxx</strong> 这些。因为我的域名是 CNAME 映射到 github 的，所以又 dig 了一下 github 对应的 ip，发现也是 <strong>198.18.1.xxx</strong>。<br>从哪个角度来看，至少都有些问题。我用的 DNSPod 域名解析平台，dig 自定义域名和 github page 域名，怎么也不能在同一个网段里。<br>搜索了一下才知道，原来 ip 198 不是公网 ip，之前我以为内网 ip 是 10&#x2F;192 这些，知识还是有局限。</p>
<blockquote>
<p>198.18.0.0&#x2F;15  198.18.0.0 – 198.19.255.255  131,072  专用网络  用于测试两个不同的子网的网间通信。<br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJGJTlEJUU3JTk1JTk5SVAlRTUlOUMlQjAlRTUlOUQlODA=">https://zh.wikipedia.org/wiki/保留IP地址<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>在家庭网络中 dig 互联网的域名，为什么 dns 解析成了 198.x 呢？最后发现是我最常使用的网络软件 <strong>Surge</strong> 引起的。<br><strong>Surge</strong> 这些年给了我很多帮助，很感谢。特意开此文，讲解 Surge 工作原理，以致敬 Surge。<br>本文会对 Socket、Wireshark、网络系统代理(http&#x2F;s、socket5、POSIX)、网络网卡代理(VIF)、VPN、DNS、DOH(SNI) 等知识点进行描述，以更加全面的讲解 Surge 的工作原理。</p>
<h1 id="致敬-Surge"><a href="#致敬-Surge" class="headerlink" title="致敬 Surge"></a>致敬 Surge</h1><p>Surge 是一款非常强大的网络调试工具，很多人都对它极为陌生，主要原因是它的售价过高，宣传和使用的人也不多。<br>我认为每一个 ITer 都应该使用它。网络在 IT 工作中时刻都需要关注，如 DNS 解析、网络流量查看和 hook、网络代理等等，这些 Surge 都可以做到。是发现和排查网络问题的神器，也可以协助工作。<br>这里我会先介绍下 Surge 的使用，或许你会感兴趣。如果以后 Surge 帮助到了你，那也是一件幸事。</p>
<span id="more"></span>

<p>Surge 只有 iOS 和 Mac 版，是订阅制，我简单介绍下订阅制，如下图：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304160218073.png" width="30%"><br>Surge iOS 和 Mac 需要单独购买，iOS 只能在非国区 apple store 下载，Mac 可以在<span class="exturl" data-url="aHR0cHM6Ly9uc3N1cmdlLmNvbS8=">官网<i class="fa fa-external-link-alt"></i></span>下载。<br>价格是有些贵，iOS 和 Mac 差不多都要 $49.9。Mac 版建议拼车，140 元左右，iOS 不建议拼车，比较麻烦。两个平台都可以试用下，效果不错再订阅。<br>这里有 Surge 的答疑，如：<span class="exturl" data-url="aHR0cHM6Ly9rYi5uc3N1cmdlLmNvbS9zdXJnZS1rbm93bGVkZ2UtYmFzZS92L3poL3JlbGVhc2Utbm90ZXMvc3VyZ2UtbWFjLTU=">Mac release notes<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9rYi5uc3N1cmdlLmNvbS9zdXJnZS1rbm93bGVkZ2UtYmFzZS92L3poL3JlbGVhc2Utbm90ZXMvc3VyZ2UtaW9z">iOS release notes<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9rYi5uc3N1cmdlLmNvbS9zdXJnZS1rbm93bGVkZ2UtYmFzZS92L3poL2xpY2Vuc2UvcHJlLXNhbGU=">常见问题<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9rYi5uc3N1cmdlLmNvbS9zdXJnZS1rbm93bGVkZ2UtYmFzZS92L3poL2xpY2Vuc2UvaW9zLWZ1cw==">订阅说明<i class="fa fa-external-link-alt"></i></span>。<br>下面是一些 Surge 的常见使用：<br><strong>http&#x2F;https&#x2F;socks5代理</strong>、<strong>机场流量转发</strong>(懂的)、<strong>软路由</strong>(相当强悍)、<strong>MitM</strong>&amp;readWrite(比金瓶梅Charles好用)、<strong>DNS代理</strong>、<strong>模块和脚本</strong>(强大功能，非专业人士不常用)。<br>iOS 和 Mac 可以互联，通过 Mac 连上 iOS 后，可以快速设置&amp;查看 iOS 上的网络流量。<br>如果对于刚需人群，软路由功能就已经让 Surge 的售价低到了尘埃里，懂得已懂。</p>
<p>下面对 Surge 是如何做网络流量劫持代理转发等核心功能，做技术分析。</p>
<h1 id="基石"><a href="#基石" class="headerlink" title="基石"></a>基石</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>在之前的<a href="https://www.yigegongjiang.com/2020/IM%E5%92%8CSocket%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8AHeart%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/">IM 和 Socket 的关系及 Heart 的必要性</a>文章中，对 Socket 套接字和 Socket库 有说明。<br>一定要理解 <strong>gethostbyname()<strong>、</strong>socket()<strong>、</strong>bind()<strong>、</strong>connect()<strong>、</strong>listen()<strong>、</strong>accept()<strong>、</strong>send()&#x2F;recv()和write()&#x2F;read()</strong> 这些 socket api，否则无法理解 tcp&#x2F;udp 的数据包传输，也无法理解下面要说的网络代理。</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>在之前的<a href="https://www.yigegongjiang.com/2020/TCP%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">TCP 数据传输过程分析</a>文章中，有对 Wireshark 如何抓包和数据分析进行过阐述。Wireshark 是网络流量分析的神器，在理解 surge 的过程中，我对 tls、sni、dns、vif、lookback 等场景都进行了抓包分析和验证，非常有帮助。<br>如果不能对虚拟网卡和物理网卡的数据包进行详细的参数级观测，理解网络代理会有不小的 gap。</p>
<h1 id="网络代理-系统代理"><a href="#网络代理-系统代理" class="headerlink" title="网络代理-系统代理"></a>网络代理-系统代理</h1><p>网络代理分为两种，分别是<strong>正向代理</strong>和<strong>反向代理</strong>。对于非服务端的 IT 工作者，可能只是听过但是不理解。我用图片描述下：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161453816.png" width="30%">

<p><strong>正向代理</strong>：客户端知道有这个代理的存在，并且主动把数据包给到这个代理，希望这个代理能够自行处理数据包，最后给自己一个满意的返回。有些时候希望代理不做任何包的修改，有些时候又希望代理能够主动移除广告等数据包等。anyway，客户端知道代理会干什么，并且知道和真实服务器之间，有这么一个代理的存在。<br><strong>反向代理</strong>：客户端不知道有这个代理存在，客户端以为在和真实服务器做数据包的流通，实际上数据包已经被反向代理给劫持。反向代理会对数据包做什么处理，客户端也不知道，如监控过滤阻拦有风险的数据包等。反向代理会优化对服务器的访问，会通过数据包的解析，知道客户端的ip等信息，做对应服务器节点的访问。反向代理有一个大杀器，就是负载均衡。anyway，反向代理对客户端是透明的。<br>对于 Surge 来说，对网络流量的劫持属于正向代理，即用户主动配置了 Surge 代理，使得本机流量让 Surge 来做处理。</p>
<p>对于机器的数据包流量，操作系统会给予一定的支持，提供不同层级的 api 开放能力，使得软件层面能够获取到流量。主要有三种途径：</p>
<ol>
<li>系统代理。操作系统会提供代理服务器配置，主动将网络流量给到代理服务器。提供的数据包是层级比较高的，<strong>高于 TCP&#x2F;UDP 传输层</strong>。</li>
<li>虚拟网卡。操作系统会提供网络协议栈里面 <strong>IP 网络层</strong>数据包的 AOP 切面，使得软件层面能被动监听到所有的 IP 层数据包。</li>
<li>socket hook。操作系统会提供数据包 hook 的能力，和 AOP 切面不同，hook 的影响未知，会对系统服务有破坏性。</li>
</ol>
<p>Surge 使用了三种途径里面的前两种，即系统代理和虚拟网卡。<br>系统代理因为是操作系统层面直接支持，数据包层级较高，数据操作最为简单，因为系统已经做了封装。<br>系统代理就是三个，分别是 http&#x2F;https&#x2F;socks5 代理，相比后面要说的虚拟网卡，代理的数据有限，但也足够用了。下面着重说明这三个系统代理。</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http 代理最为简单，也是 https 代理的基础。因为是应用层协议，所以操作起来也最方便。简单画图理解下：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161543953.png" width="30%">

<p>提取一下关键点：</p>
<ol>
<li>Client(浏览器或者应用程序)，在发起 http 请求的时候，不在进行被请求域名的 DNS 解析，流量强制被操作系统转到 Proxy，Client 强制和 Proxy 之间建立 Socket 通道。</li>
<li>基于 TCP 三次握手，Client 和 Proxy 之间建立虚拟 socket 通道，各自生成 socket 套接字用于数据包的写入和接收。</li>
<li>Proxy 接收到所有 Client 原本要发到目标服务器的数据包，并做内部处理。（如果是广告，可能返回404。如果流量正常，可以继续去请求一下目标服务器。反正可以做各种处理。）</li>
<li>Proxy 处理完成后，对 socket_proxy 进行写入，socket_client 会读取到。</li>
</ol>
<p>着重说一下上面的第 1 点和第 3 点，即 DNS 解析和 Proxy 内部处理的细节。</p>
<p>对于 DNS 解析，因为数据将要被 Proxy 代理，Client 将要和 Proxy 建立 socket 虚拟通道。<br>这时候，Client 已经和目标服务器之间没有任何关联，而目标域名的 DNS 解析就是为了拿到目标服务器的 IP 然后建立 Socket 套接字。<br>所以 Client 没有目标域名 DNS 解析的必要。<br>但是 Client 需要对 Proxy 做域名解析，因为有了 Proxy 的 IP，才能建立 Socket。Proxy 可能是本机的一个服务，也可能是外网服务。如果是本机服务，那就是 127.0.0.1 回路 ip 了。</p>
<p>对于 Proxy 内部处理，因为 HTTP 是明文的，所以 Proxy 可以拿到明文的数据。这样，Proxy 就可以拿到要请求的域名。<br>此时，Proxy 可以内建域名白名单，匹配上广告，可以直接返回 404。匹配上国内域名，可以直接代请求一下然后将数据返回。匹配上 google，根据自己是否能够直连外网，做直接请求或者二次转发之类的。</p>
<p>Mac http 代理的设置如下：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161611321.png" width="10%">

<p>http proxy python 实现如下，要理解 client_socket 和 server_socket 两个 socket 的生成和处理。<br>(From ChatGPT - “用 python 写一个 http 代理，处理 get post delete head 等请求。”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def handle_client(client_socket):</span><br><span class="line">    # 接收客户端请求数据</span><br><span class="line">    request_data = client_socket.recv(1024)</span><br><span class="line">    # 解析请求行，获取请求方法、URL 和 HTTP 版本号</span><br><span class="line">    request_line = request_data.split(b&#x27;\r\n&#x27;)[0]</span><br><span class="line">    method, url, http_version = request_line.split(b&#x27; &#x27;)</span><br><span class="line">    # 构造代理服务器请求地址</span><br><span class="line">    proxy_url = b&#x27;http://&#x27; + url</span><br><span class="line">    # 发送代理服务器请求</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as proxy_socket:</span><br><span class="line">        # 解析代理服务器地址</span><br><span class="line">        proxy_host = proxy_url.split(b&#x27;//&#x27;)[1].split(b&#x27;/&#x27;)[0]</span><br><span class="line">        proxy_port = 80</span><br><span class="line">        # 建立连接并发送请求数据</span><br><span class="line">        proxy_socket.connect((proxy_host, proxy_port))</span><br><span class="line">        proxy_socket.sendall(request_data)</span><br><span class="line">        # 接收代理服务器响应并发送给客户端</span><br><span class="line">        while True:</span><br><span class="line">            response_data = proxy_socket.recv(1024)</span><br><span class="line">            if not response_data:</span><br><span class="line">                break</span><br><span class="line">            client_socket.sendall(response_data)</span><br><span class="line"></span><br><span class="line">def run_server():</span><br><span class="line">    # 创建套接字并绑定到本地地址和端口</span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((&#x27;localhost&#x27;, 8888))</span><br><span class="line">    server_socket.listen(5)</span><br><span class="line">    print(&#x27;Proxy server is running on port 8888...&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        # 接受客户端连接并创建线程处理请求</span><br><span class="line">        client_socket, address = server_socket.accept()</span><br><span class="line">        print(f&#x27;Request from &#123;address&#125;&#x27;)</span><br><span class="line">        t = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    run_server()</span><br></pre></td></tr></table></figure>

<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>理解了 http 代理之后，理解 https 就不困难了。<br>上面我们需要知道目标域名才能够做上面提到的转发过滤等工作。<br>可 https 是加密的，作为 proxy，我们不应该知道 client 和目标服务器之间的数据包内容。可是不知道数据包内容，我们就不知道目标服务器的域名。这是一个死循环。<br>https 的 ssl&#x2F;tls 本身很复杂，但因为是系统代理，所以操作系统简化了不少事情。核心在于两个：</p>
<ol>
<li>操作系统主动发送 http 的 connect 数据包，将目标服务器的域名给到 proxy。</li>
<li>proxy 不能感知数据包内容，只能根据域名做相关处理。</li>
</ol>
<p>https 代理整体流程和 http 没有变化，就是多了一个 http connect 操作，之后的数据包都是加密的转发(包括 tls 认证过程和之后的对称加密传输)。</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161643722.png" width="30%">

<p>大家使用金瓶梅 Charles 的时候，虽然没有设置 MitM 证书，依旧可以看到当前正在进行哪个 https 域名的访问。<br>按照预期，https 数据是加密的，域名也在加密数据包里面，Charles 不应该看到。<br>到这里大家应该理解了吧，http connect 操作会将域名给到 proxy，所以 Charles 虽然不知道数据包内容是啥，依旧可以展示在面板上。</p>
<p>https proxy python 实现如下，要注意对 connect 的处理，是返回 client 200 Established，这样 client 才会继续发送后续的数据包。<br>(From ChatGPT - “用 python 写一个 https 代理，处理 connect 请求。”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import ssl</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def handle_client(client_socket):</span><br><span class="line">    # 接收客户端请求数据</span><br><span class="line">    request_data = client_socket.recv(1024)</span><br><span class="line">    # 解析请求行，获取请求方法、URL 和 HTTP 版本号</span><br><span class="line">    request_line = request_data.split(b&#x27;\r\n&#x27;)[0]</span><br><span class="line">    method, url, http_version = request_line.split(b&#x27; &#x27;)</span><br><span class="line">    if method == b&#x27;CONNECT&#x27;:</span><br><span class="line">        # 解析请求行，获取请求方法、目标主机和端口号</span><br><span class="line">        _, target_host, target_port, _ = url.split(b&#x27;:&#x27;) + [b&#x27;&#x27;]</span><br><span class="line">        target_port = int(target_port)</span><br><span class="line">        # 建立与目标主机的加密连接</span><br><span class="line">        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as proxy_socket:</span><br><span class="line">            proxy_socket.connect((target_host, target_port))</span><br><span class="line">            proxy_socket = ssl.wrap_socket(proxy_socket, server_side=False)</span><br><span class="line">            # 响应客户端 CONNECT 请求</span><br><span class="line">            response_data = b&#x27;HTTP/1.1 200 Connection Established\r\n\r\n&#x27;</span><br><span class="line">            client_socket.sendall(response_data)</span><br><span class="line">            # 交换数据</span><br><span class="line">            while True:</span><br><span class="line">                data = client_socket.recv(1024)</span><br><span class="line">                if not data:</span><br><span class="line">                    break</span><br><span class="line">                proxy_socket.sendall(data)</span><br><span class="line">                response_data = proxy_socket.recv(1024)</span><br><span class="line">                client_socket.sendall(response_data)</span><br><span class="line">    else:</span><br><span class="line">        # 构造代理服务器请求地址</span><br><span class="line">        proxy_url = b&#x27;http://&#x27; + url</span><br><span class="line">        # 发送代理服务器请求</span><br><span class="line">        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as proxy_socket:</span><br><span class="line">            # 解析代理服务器地址</span><br><span class="line">            proxy_host = proxy_url.split(b&#x27;//&#x27;)[1].split(b&#x27;/&#x27;)[0]</span><br><span class="line">            proxy_port = 80</span><br><span class="line">            # 建立连接并发送请求数据</span><br><span class="line">            proxy_socket.connect((proxy_host, proxy_port))</span><br><span class="line">            proxy_socket.sendall(request_data)</span><br><span class="line">            # 接收代理服务器响应并发送给客户端</span><br><span class="line">            while True:</span><br><span class="line">                response_data = proxy_socket.recv(1024)</span><br><span class="line">                if not response_data:</span><br><span class="line">                    break</span><br><span class="line">                client_socket.sendall(response_data)</span><br><span class="line"></span><br><span class="line">def run_server():</span><br><span class="line">    # 创建套接字并绑定到本地地址和端口</span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((&#x27;localhost&#x27;, 8888))</span><br><span class="line">    server_socket.listen(5)</span><br><span class="line">    print(&#x27;Proxy server is running on port 8888...&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        # 接受客户端连接并创建线程处理请求</span><br><span class="line">        client_socket, address = server_socket.accept()</span><br><span class="line">        print(f&#x27;Request from &#123;address&#125;&#x27;)</span><br><span class="line">        t = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    run_server()</span><br></pre></td></tr></table></figure>

<h2 id="socks5"><a href="#socks5" class="headerlink" title="socks5"></a>socks5</h2><p>对于系统代理，操作系统除了可以将 http&#x2F;https 这两个应用层数据包给到 proxy 外，还可以将 socket 套接字给到 proxy。http&#x2F;https 是基于 socket 套接字编程的，所以 socket 的数据包范围会更大一些，还能够转发其他应用层协议或者自定义协议。<br>这里就要用到 socks5 协议。<br>socks5 本身是一套协议，非应用层协议，而是一种系统代理传输协议，即操作系统如何将 socket 数据包给到 proxy 的协议。<br>具体协议可以看一下<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU09DS1M=">Wiki<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SOCKS5请求格式（以字节为单位）：</span><br><span class="line">VER-CMD-RSV-ATYP-DST.ADDR-DST.PORT</span><br><span class="line">1 - 1 - 0x00 - 1 - 动态 - 2</span><br><span class="line"></span><br><span class="line">VER是SOCKS版本，这里应该是0x05；</span><br><span class="line"></span><br><span class="line">CMD是SOCK的命令码</span><br><span class="line">-&gt;0x01表示CONNECT请求</span><br><span class="line">-&gt;0x02表示BIND请求</span><br><span class="line">-&gt;0x03表示UDP转发</span><br><span class="line"></span><br><span class="line">RSV 0x00，保留</span><br><span class="line"></span><br><span class="line">ATYP DST.ADDR类型</span><br><span class="line">-&gt;0x01 IPv4地址，DST.ADDR部分4字节长度</span><br><span class="line">-&gt;0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。</span><br><span class="line">-&gt;0x04 IPv6地址，16个字节长度。</span><br><span class="line"></span><br><span class="line">DST.ADDR 目的地址</span><br><span class="line"></span><br><span class="line">DST.PORT 网络字节序表示的目的端口</span><br></pre></td></tr></table></figure>

<p>具体来说，我们还是可以在 proxy 里面拿到数据包，但是需要进行字节级别的偏移计算，才能够拿到我们想要的数据。操作系统会将 socket 数据包，按照 socks5 协议的标准提供到 Proxy。<br>而我们的目标还是要拿到域名。https 是通过 connect 给的，socks5 就需要字节偏移来获取。<br>画图理解下：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161710350.png" width="30%">

<p>socks5 proxy python 实现如下，要注意对域名的获取。<br>(From ChatGPT - “用 python 写一个 socks5 代理。”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def handle_client(client_socket):</span><br><span class="line">    # 接收客户端连接请求</span><br><span class="line">    data = client_socket.recv(1024)</span><br><span class="line">    # 发送协商响应，仅支持无认证方式</span><br><span class="line">    response = b&quot;\x05\x00&quot;</span><br><span class="line">    client_socket.sendall(response)</span><br><span class="line">    # 接收客户端连接请求，解析目标主机和端口号</span><br><span class="line">    data = client_socket.recv(1024)</span><br><span class="line">    mode = data[1]</span><br><span class="line">    if mode == 1:  # CONNECT</span><br><span class="line">        addrtype = data[3]</span><br><span class="line">        if addrtype == 1:  # IPv4</span><br><span class="line">            addr = socket.inet_ntoa(data[4:8])</span><br><span class="line">            port = int.from_bytes(data[8:], byteorder=&#x27;big&#x27;)</span><br><span class="line">        elif addrtype == 3:  # 域名</span><br><span class="line">            addrlen = data[4]</span><br><span class="line">            addr = data[5:5+addrlen].decode()</span><br><span class="line">            port = int.from_bytes(data[5+addrlen:], byteorder=&#x27;big&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            client_socket.close()</span><br><span class="line">            return</span><br><span class="line">        # 建立与目标主机的连接，并响应客户端连接请求</span><br><span class="line">        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as proxy_socket:</span><br><span class="line">            proxy_socket.connect((addr, port))</span><br><span class="line">            response = b&quot;\x05\x00\x00\x01&quot;</span><br><span class="line">            response += socket.inet_aton(&#x27;0.0.0.0&#x27;) + (0).to_bytes(2, byteorder=&#x27;big&#x27;)</span><br><span class="line">            client_socket.sendall(response)</span><br><span class="line">            # 交换数据</span><br><span class="line">            while True:</span><br><span class="line">                data = client_socket.recv(1024)</span><br><span class="line">                if not data:</span><br><span class="line">                    break</span><br><span class="line">                proxy_socket.sendall(data)</span><br><span class="line">                response_data = proxy_socket.recv(1024)</span><br><span class="line">                client_socket.sendall(response_data)</span><br><span class="line">    else:</span><br><span class="line">        client_socket.close()</span><br><span class="line"></span><br><span class="line">def run_server():</span><br><span class="line">    # 创建套接字并绑定到本地地址和端口</span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((&#x27;localhost&#x27;, 8888))</span><br><span class="line">    server_socket.listen(5)</span><br><span class="line">    print(&#x27;SOCKS5 proxy server is running on port 8888...&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        # 接受客户端连接并创建线程处理请求</span><br><span class="line">        client_socket, address = server_socket.accept()</span><br><span class="line">        print(f&#x27;Request from &#123;address&#125;&#x27;)</span><br><span class="line">        t = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    run_server()</span><br></pre></td></tr></table></figure>

<h2 id="终端默认为什么不走代理"><a href="#终端默认为什么不走代理" class="headerlink" title="终端默认为什么不走代理"></a>终端默认为什么不走代理</h2><p>使用过网络代理工具的同学都知道，终端默认是不走代理的，即使开了全局代理。<br>但是很多人不知道为什么，更不知道为什么加了 <strong>http_proxy</strong>、<strong>https_proxy</strong> 这些配置后，就能够走代理了。<br>其实这也是系统代理的一些弊端，那就是系统代理的数据有限，更多的是按照当前系统定制接口开发的网络流量，可以被系统代理接管。比如 iOS&#x2F;Mac 上面的 Cocoa 套件，默认就是支持系统代理的。<br>终端的工具，都不是基于 Cocoa 套件开发的，一般都是跨平台的，使用 c&#x2F;ruby 等运行时网络库来实现网络请求。这些网络请求，是 POSIX 标准的，而 POSIX 标准的网络流量默认不过系统代理（别问，操作系统就是不给过）。</p>
<p>这里说到了 POSIX 标准。但是如果不理解什么是 POSIX 标准，那还是不理解终端流量为什么不过代理。POSIX 其实一敲就懂。</p>
<h3 id="POSIX-是什么"><a href="#POSIX-是什么" class="headerlink" title="POSIX 是什么"></a>POSIX 是什么</h3><p>POSIX 可以从 Wiki 上面查，但是大概率看了也不理解。其实它就是一套 API 统一标准，就和“书同文车同轨统一度量衡”一样，我这里用 C 的运行时库里面的线程来说明：<br>C 语言有标准库和运行时库，具体可以看一下之前的文章：<a href="https://www.yigegongjiang.com/2020/%E4%BB%8ECore%20Foundation%E7%9C%8B%E6%9B%B4%E5%A4%A7%E4%B8%96%E7%95%8C/#C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%92%8CC%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%85%B3%E7%B3%BB">从 Core Foundation 看更大世界 -&gt; C 运行时和 C 标准库的关系</a>。<br>如果我们要通过 C 语言来实现多线程操作，就需要使用线程 api。毕竟如果 C 语言本身没有实现，那么我们还要处理各种锁机制和内核线程之间的关系，几乎不可能。关于锁有多么的麻烦，可以看之前文章：<a href="https://www.yigegongjiang.com/2022/%E9%94%81%20-%20%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8C%87%E2%86%91/">锁 - 共享数据安全指↑</a><br>恰巧，C 标准库就是没有制定多线程技术的实现(最近才制定)，所以 Windows 平台的 MCRT 运行时库和 Linux 平台的 glibc 运行时库，都没有一个 C 语言标准的多线程实现。<br>事实上 MCRT 和 glibc 本身都实现了多线程 api，因为没有 C 标准库制定标准，如果 MCRT 和 glibc 各自为政，两边的 thread api 就会有命名和功能上的差异，开发人员就不能夸平台执行了。<br>这时候就有了 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUE9TSVglRTclQkElQkYlRTclQTglOEI=">POSIX 线程<i class="fa fa-external-link-alt"></i></span> 标准，现在 MCRT 和 glibc 都依据 POSIX 线程标准来实现功能和开放 api，两端就统一了。<br>这就是 C 运行时库里面 <strong>&lt;pthread.h&gt;</strong> 的标准 api，也是大家一直在使用的，可以在 UNIX、Linux、MacOS、iOS、Android 等各个系统平台上使用。</p>
<p>后面 C 标准库更新，也做了自身线程的标准，就是 <strong>&lt;threads.h&gt;</strong> ，但它不是 POSIX 标准的，更多用于 C++11 标准中的线程库，主要适用于C++开发。</p>
<h3 id="终端走系统代理"><a href="#终端走系统代理" class="headerlink" title="终端走系统代理"></a>终端走系统代理</h3><p>终端要走系统代理，就需要在 zshrc 等配置文件中配置 http_proxy、https_proxy、all_proxy 这些。如果一次窗口周期使用，还可以用 export 来做。<br>为什么 export 可以使得本次窗口周期内等所有子进程都走代理，可以看之前的文章：<a href="https://www.yigegongjiang.com/2022/Shell%E5%92%8C%E8%BF%9B%E7%A8%8B/">Shell 和进程</a><br>而 http_proxy 这些配置可以使得终端网络走系统代理，是因为 POSIX 标准下的网络实现，认 http_proxy 这个流量转发配置。<br>然而这个配置的认证，也是可以由开发人员自定义的，所以安全起见，还是做如下配置，把一些可能的情况都配全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:6152</span><br><span class="line">export HTTP_PROXY=http://127.0.0.1:6152</span><br><span class="line">export https_proxy=http://127.0.0.1:6152</span><br><span class="line">export HTTPS_PROXY=http://127.0.0.1:6152</span><br><span class="line">export all_proxy=socks5h://127.0.0.1:6153</span><br><span class="line">export ALL_PROXY=socks5h://127.0.0.1:6153</span><br></pre></td></tr></table></figure>

<h1 id="网络代理-虚拟网卡"><a href="#网络代理-虚拟网卡" class="headerlink" title="网络代理-虚拟网卡"></a>网络代理-虚拟网卡</h1><p>前面说到系统代理的数据包比较有限，就是 http&#x2F;https&#x2F;socks5 三种。对于很多非应用层协议，就不会过系统代理了。<br>Surge 有一个选项，叫增强模式，开启增强模式后，就会通过虚拟网卡接管 IP 网络层数据包实现转发。这样是可以接管本机全局流量的，除了有丢丢费 CPU 和 Mitm 有误判，其他都好。<br>尤其，在查看一些使用底层网络库的 app 流量的时候，虚拟网卡就是扛把子的。真要通过 wireshark 来快速查看本机或者移动设备的流量，那还是要耗费不少时间的，而且不直观。<br>对虚拟网卡做代理实现，现在就 Surge 有，其他工具都没有。wireshark 只能看流量，金瓶梅 charles 只能做系统代理。</p>
<p>因为虚拟网卡工作在 IP 网络层，对这一层的数据进行代理，为了识别到域名，就需要不少的工作量了。核心在于两点：</p>
<ol>
<li>域名捕获</li>
<li>分片包重组</li>
</ol>
<p>在系统代理的时候，操作系统会将域名给到 Proxy，拿到了域名就好办事情了。但是到了 IP 网络层，DNS 域名解析早就完成了，这个时候只能拿到 IP，不可能在拿到域名了(除非 http 这样的明文，但没有意义)。<br>所以这个时候，就需要主动对域名进行捕获。Surge 的做法是捕获到 DNS 解析的数据包后，强制返回 198.18 网段的内网 ip，并将内网 ip 和域名做映射（这就是文章开头我说到的，dig 本网站 ip 是 198 的困惑）。<br>这样 client 以为 google 的 ip 是 198.18.x，发送的数据包就会携带这个 ip。在 IP 网络层收到这个 ip 的数据包之后，就知道访问的是 google 了。<br>这样就完成了<strong>域名捕获</strong>的工作。</p>
<p>但是域名捕获又会带来另一个问题，就是<strong>分片的数据包必须要做重组</strong>。<br>对于数据包分片，在 <a href="https://www.yigegongjiang.com/2020/TCP%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">TCP 数据传输过程分析</a> 里面有说明，可以查阅下。<br>概要来说，IP 网络层的数据包，有 icmp&#x2F;ping 这些不过传输层的数据，也有 tcp&#x2F;udp 这些传输层过来的数据。tcp 会尽量阻止数据包分片的发生甚至可以强制不分片，而 udp 就完全不会管这个了。<br>综上，因为 dns 解析过程中分片的数据包标识非目标主机，这里又对数据包强制接管及转发，那么一定要做分片重组，否则目标主机无法完成重组操作。<br>当然重组逻辑本身可控，主要通过 IP 数据包里面的 16 位包标识 ID 进行重组。</p>
<p>下面还是大图看下具体流程：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161910996.png" width="30%">

<p>整体来说，走虚拟网卡接管网络流量，还是比较费事的。需要多个 socket 的数据中转。</p>
<h1 id="Surge和VPN的差异"><a href="#Surge和VPN的差异" class="headerlink" title="Surge和VPN的差异"></a>Surge和VPN的差异</h1><p>Surge 不是 VPN，两者的技术实现有重叠。<br>我们一直说访问不了 Google，就买个 VPN，其实是泛化的概念。很多时候我们不是在使用 VPN，而是指网络代理。</p>
<p>VPN 的确可以实现翻墙，但不是主要目的，VPN 也不是为了翻墙而做的。<br>VPN 是虚拟隧道，主要是为了保护数据隐私。VPN 是系统提供的能力，在 系统代理 之外，操作系统还提供了 VPN 的配置，VPN 还有多个配置协议，这些协议工作在不同的网络模型层级上。<br>最终，VPN 也是通过整合应用层、传输层、IP 网络层、数据链路层的数据包，然后根据不同配置协议进行加密，最后将数据包传输到具体的中转服务器。<br>鉴于 VPN 的使用场景，中转服务器一般都是企业内部网络，员工用来内部访问企业内网。<br>而我们使用 VPN 翻墙，主要是这个中转服务器，变成了机场，相当于 VPN 帮我们通过机场转发了本机流量。</p>
<p>VPN 是操作系统层面提供的数据代理，支持的协议也比较有限，如 IPSec、L2TP 等。<br>对于过墙用户来说，VPN 的网络数据包具有明显的特征(操作系统提供的嘛，具有一定规律)，根据这些特征可以很明显的知道这些数据是过墙的数据，从而予以拦截（虽然看不到数据包内容，但是根据特征分析大概率是过墙数据）。</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161929876.png" width="10%">

<p>我们将机场给的配置，配置在特定的软件上，实现网络代理。<br>虽然一样能访问 Google，但这不是 VPN。<br>虽然不是 VPN，但和 VPN 技术方案有一致。<br>上面 Surge 实现的系统代理和虚拟网卡，本身不是 VPN，但是可以为本机流量实现中继代理(机场)，从而过墙。<br>Surge 这些软件，主要就是走特定协议，抹平数据包的特征，使得数据包不具有明显特征，骗过墙。</p>
<blockquote>
<p>没有特征本身就是特征。没有墙过滤不了的数据，只是相互博弈的一个过程。</p>
</blockquote>
<p>还有一个点，VPN 本身不是为了过墙而做的，所以对于所有流量，都会发往中继代理。而 Surge 这些代理软件，可以根据域名来做规则引擎验证，从而实现流量分流。<br>这也是前面一直在说的，Surge 希望拿到域名的原因。系统代理的时候，操作系统主动提供了域名。虚拟网卡的情况下，Surge 捕获了域名。</p>
<p>看大图吧：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304161955165.png" width="30%"></p>
<p>这里还有一个补充，也是大家认为过墙专指 VPN 的原因。<br>在 iOS 系统上，是没法像 Mac 上面进行 http&#x2F;https&#x2F;socks5 配置的。也就是没法直接进行系统代理。<br>iOS 系统开放了 Network Extension，通过 Extension 可以在应用内部进行系统全局配置，可以做系统代理和虚拟网卡等开发工作。<br>但是如果使用 Extension，就需要开启 iOS 系统的 VPN，这是唯一接管 iOS 系统网络流量的方式。<br>所以很多人有过墙就是 VPN 的误区。</p>
<h1 id="MitM"><a href="#MitM" class="headerlink" title="MitM"></a>MitM</h1><p>MitM 不做过多解释了，对 SSL&#x2F;TLS 熟悉一些，理解 MitM 并不难。<br>在 Surge 的实现里，对系统代理里面的 HTTPS&#x2F;socks5，比较方便实现 MitM，因为 ssl&#x2F;tls 数据包特征明显，直接 MitM 即可。<br>但 Surge 强大的地方，在于还可以对 虚拟网卡 的劫持流量进行 MitM。<br>原理也是一样，只是这个时候数据包不仅仅有 HTTPS 流量，还有其他各种数据包，所以会有误判。<br>但挺香，尤其有些 app 没有走系统网络接口编程，系统代理抓不到。通过虚拟网卡来查看明文，在工作上还是挺有帮助的。<br>我这边的经验是，的确可以看到明文，但有时候有截断，只能看到部分。但总比没有强。<br>这个如果通过 wireshark 来分析，其实挺累的。</p>
<p>很多成熟的大型应用，也都对 MitM 有校验。比如在进行证书验证的时候，判断证书是否符合预期，不符合预先设置的，则不予通过，这时候 MitM 就会失败了。<br>了解 MitM 的原理，防护也都会有相应的办法。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>Surge 对 DNS 解析的处理方案，是：完全抛弃了系统的 DNS 解析，全部自行实现。<br>Surge 之所以能做到这一点，是因为：</p>
<ol>
<li>系统代理的时候，数据包给到 Proxy 之前，并没有进行 DNS 解析。给到 Proxy 之后，Surge 会拿到域名，完全可以自己来做 DNS 解析了。</li>
<li>虚拟网卡的时候，数据包到达网络层之前，DNS 解析被 Surge hook 了，返回了 198.18.x 内网 ip。等到组装分片的网络层数据包后，完全可以自己目标域名的 DNS 解析了。</li>
</ol>
<p>所以，Surge 完全有时机来自行完成 DNS 解析工作。Surge 是怎么做 DNS 解析的呢？<br>实际上，Surge 虽然抛弃了系统的 DNS 解析，但也没有完全重写。Surge 采用了两个策略来优化 DNS 解析：</p>
<ol>
<li>并发解析：Surge 是对多个 DNS 解析服务器同时发起 DNS 解析工作，谁最先解析完成了，谁就是第一响应者。</li>
<li>缓存解析(乐观解析)：DNS 解析会存在过期，如果完全按照 DNS 过期时间来计算，那么会有很多无效的解析，因为服务器的 IP 一般都不会变。Surge 会继续使用上一次的 DNS 解析结果，当建立连接失败后，会重新使用刚才解析得到的 IP 重新完成建联工作。这会有效减少 DNS 过期时间带来的影响。</li>
</ol>
<p>Surge 默认对 DNS 的解析操作，的确有效减少了解析耗时。但并没有解决 DNS 劫持等问题。这里推荐看一下网红 IM 网站：<span class="exturl" data-url="aHR0cDovL3d3dy41MmltLm5ldC90aHJlYWQtMjEyMS0xLTEuaHRtbA==">全面了解移动端DNS域名劫持等杂症：原理、根源、HttpDNS解决方案等<i class="fa fa-external-link-alt"></i></span>，对于 DNS 带来的问题，说的非常详细。</p>
<p>大家如果对 DNS 解析有疑惑，最好的方式是实战，非常简单的验证即可。这里我推荐两个捷径：</p>
<ol>
<li>使用 dig&#x2F;host&#x2F;ping 等命令，来验证指定域名的解析。其中 dig 是神器，通过 <strong>+trace</strong> 可以看到完成的解析流程。</li>
<li>查看具体的 DNS 解析平台对于域名的解析配置，这里我给出本网站的解析后台截图(没啥隐私):<br>这样，后面在看到 wireshark DNS 过滤结果里面的 A&#x2F;AAAA，就不会迷惑茫然失措了。</li>
</ol>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334647.png" width="30%">
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334958.png" width="30%">
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162334490.png" width="30%">

<p>实践是最好的理解，1 小时，就对 DNS 的递归解析、迭代查询掌握清楚了。<br>anyway，DNS 也是 socket 遍历里面的一环，即 gethostbyname() 函数。对于这个函数，其实有一个重要的杀器，用于解决 DNS 劫持的问题，那就是 DOH。</p>
<h1 id="DOH-httpdns"><a href="#DOH-httpdns" class="headerlink" title="DOH(httpdns)"></a>DOH(httpdns)</h1><p>记的有一次问过一个候选人问题，就是对于一个网络请求，是 TCP 三次握手先发生，还是 HTTPS 安全认证先发生。<br>这里也会有一个小问题：https 网络请求发出前，会先做 ssl&#x2F;tls 认证，认证通过后发送的加密数据包才会携带域名。那么 ssl&#x2F;tls 认证的时候，服务器怎么知道请求的域名，然后给予相应域名的证书呢？<br>这里其实有个小知识，就是 SNI，即 tls 的 client hello 消息发出的时候，数据包里面会携带当前请求域名，或许很多人对此不知道：</p>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202304162344424.png" width="30%">

<p>SNI，就是上面截图里面的：Server Name Indication。<br>如果服务器 Nginx 配置来 N 个域名的解析，那么 Nginx 就会根据 SNI，知道当前请求的域名是什么，然后返回对应的 ssl&#x2F;tls CA 证书（如果 Nginx 只配置一个域名，那其实有没有 SNI 都没有关系了）。</p>
<p>Surge 默认已经对 DOH 做支持，在软件的控制面板里面有 DNS over https&#x2F;https&#x2F;3&#x2F;QUIC 的配置。</p>
<p>DOH 的支持需要一定的条件，准确来说，需要 client 支持，因为 DOH 的实现，会带来跨域、http 请求头 host 变为 ip 的预准备工作等：</p>
<ol>
<li>client 需要先进行 https 请求，获取目标域名的 ip，而后将域名请求转为 ip 请求（1. 实现 gethostbyname 2. 强行把请求的域名变成 ip）。</li>
<li>client 需要在 ssl&#x2F;tls 认证的时候，将 SNI 变为域名，而不能是 ip，否则服务器不知道返回那个域名的证书。</li>
<li>client 拿到服务器证书后，需要自行进行证书校验，需要再把 ip 转为域名，和证书里面的域名做匹配，匹配成功才算证书校验合格。</li>
</ol>
<p>这些在 Mac 端并没有什么问题，上面的系统代理和网卡代理都可以看到，并不需要 client 主动的感知 DNS，Surge 完全可以全部劫持。目前 Chrome 等浏览器都都做了 DOH 的支持。<br>但是在 app 上还没法完美支持，这里说的就是 Android 和 iOS。<br>Android 基于常用的 OKHttp 还比较方便实现，因为 OKHttp 提供 gethostbyname() 接口的实现，这样在 DNS 阶段就可以做 DNS 的hook。然后对 SNI 做一个反射，就可以完成。<br>iOS 就相当麻烦了，主要原因是系统没有提供 SNI 的 hook 方式，即使通过 fishhook 完成了 gethostbyname() 的 hook，也没法顺利实现 SNI 的 hook。当然也有解，但是难度很大，很容易出错。这里还是期待系统级别的支持。</p>
<p>其实国内对于 DOH 的支持还不足，几个大的互联网公司的确有支持，但是比较黑盒，更多是解决企业问题。<br>但 DNS 的劫持问题，确实极为恶劣。大企业即使不用担心墙，也实实在在被 DNS 劫持伤害很大。而对于像我这样低微到尘埃里的人，其实 DNS 劫持，就是看大千世界一个跨不过去的坎。</p>
<h1 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h1><p>谨以此文，致敬 Surge。也致敬用了好多年的机场(就不说哪家了)。<br>感谢互联网带来的科技繁盛和文明进步，也感谢窃火者，给岁月以文明。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYW51YWwubnNzdXJnZS5jb20vYm9vay91bmRlcnN0YW5kaW5nLXN1cmdlL2NuLyMlRTYlQTYlODIlRTglQkYlQjA=">Surge 官网技术说明<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>为众人抱薪者，不可使其冻毙于风雪。<br>为大众谋福利者，不可使其孤军奋战。<br>为自由开路者，不可使其困顿于荆棘。</p>
<p>- from 窃火者</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Follow me by other channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/one_gongjiang">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/gongjiang">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="mailto:one.gongjiang@gmail.com">
            <span class="icon">
              <i class="fa fa-envelope"></i>
            </span>

            <span class="label">Email</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag"># 计算机原理</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 计算机基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/%E5%8F%88%E5%8D%81%E5%B9%B4-%E8%87%B3%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B/" rel="prev" title="又十年-至三十而立">
                  <i class="fa fa-chevron-left"></i> 又十年-至三十而立
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/network_privacy/" rel="next" title="对互联网隐私的一些想法">
                  对互联网隐私的一些想法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">Light Mode (Better for light mode to discuss, base github, cannot commen can email me)</a></li>
            <li class="tab"><a href="#comment-utterances">Dark Mode</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments utterances-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">one.gongjiang艾特gmail.com 所有文章均为原创。我不介意任意形式的转载，但最好不要修改内容。因转载或者修改内容导致的任何问题，我均不负责。如果你真的担心版权，可邮联。评价需要外网，这是枷锁，也是照妖镜。</span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.yigegongjiang.com/2023/for_surge/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yigegongjiang","repo":"yigegongjiang_discuss","client_id":"65bebc0a049450012bda","client_secret":"06004e7143dc59f263a8d1bd1893dcf66d6bb7ee","admin_user":"yigegongjiang","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"e2d80ebfa05d878b3d178a0cb52a2abf"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"yigegongjiang/yigegongjiang_discuss","issue_term":"title","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
