---
title: 函数调用栈之彻底理解
date: 2022-03-20 23:28:58 08:00
categories:
- 技术
tags:
- C
- 计算机原理
keywords: 函数调用栈,
---

说到函数调用栈，大家应该都很清楚了，就是一个栈结构的入栈和出栈，使得被调用函数执行完毕后能够返回到调用函数处继续执行。（但实话说，函数调用栈和数据结构栈还是有一些差异的，虽然可以当作一个东西来理解，我更倾向于函数调用栈是数据结构栈的高一层级的抽象。）
但据我从网上的帖子查看和同事间观察，其实大家并不完全理解函数调用栈的实现过程，只是知道这个大概流程，说到 call、ret 等汇编的具体实现，就不理解了。或者调用函数在 call 一个子函数的时候，会把调用函数处的下一个指令地址保存在函数调用栈上，这个是什么时机保存的以及保存在哪个位置？其实也说不明白。
本篇技干就是为了彻底理解函数调用栈，从基础汇编的角度彻底理解函数执行过程。
当然，对于还不了解函数调用栈的同学，最好先了解熟悉下，再来食用。如果确实想霸王硬上弓，我也明确的说，本技干食用口味也一样鲜美，绝对可以少走弯路。如果觉得看不下去，那么很可能是基础能力还薄弱，熟悉栈数据结构 + 基础汇编后，再回头看就不会觉得索然无味了。

## 开局一张图

![][image-1]

<!-- more -->

函数执行过程大致就是图中样子。其中函数栈的内存布局因操作系统和 cpu 架构的不同或许有差异，但不是重点。图中展示为 Mac 系统。
从图中可以看到，程序执行的流程就是函数调用的过程。当函数调用完毕，程序也就停止了。所以函数调用对程序执行的影响还是非常大的，函数是指令层级的超高度抽象。

这里就先引出一些名词，后面就不在论述了。
内存布局：从上往下依次是内核区、栈区、共享数据区(动态库)、堆区、数据区、代码区、留置区。这些区域的划分都是虚拟内存，并非物理内存。越往上内存地址越大，越往下内存地址越小。这里研究的函数调用栈就是在栈区。
栈区：从上往下使用，即先执行的函数的内部变量的虚拟内存地址一定大于后执行的子函数的内部变量的虚拟内存地址。
call：call 指令用于调用子函数
push： push 指令用于将寄存器的值入栈保存到栈区内存中。
pop： pop 指令用于将当前栈区指向内存的值保存到寄存器中。
ret： ret 指令用于结束当前子函数调用，回到被调用处继续后续指令的执行。
rbp：栈顶指针寄存器，值为栈顶内存地址
rsp： 栈底指针寄存器，值为栈底内存地址

## 子函数调用前的准备

函数的作用是给予特定的输入，给出特定的输出。所以对子函数的调用，一个是传给子函数参数，一个是获取子函数的返回值。返回值在后面说，这里先说传参。

```c

#include <stdio.h>

int sub(int a, int b) {
  int t = a + b;
  return t;
}

int main(void) {
  int a = 1;
  int b = 2;
  int p = sub(a, b);
  printf("the return value is:%d\n", p);
  return 0;
}

```

示例代码中，main 对 sub 函数的调用，需要 a 和 b 两个参数，下面通过 main 的汇编，可以看下参数是如何准备起来的：

```c
 `main:
    0x100003f30 <+0>:  pushq  %rbp
    0x100003f31 <+1>:  movq   %rsp, %rbp
    0x100003f34 <+4>:  subq   $0x10, %rsp			# 准备 0x10 大小即 16 字节的留置内存区域，用于存放各种参数
    0x100003f38 <+8>:  movl   $0x0, -0x4(%rbp)		# 0 值写入，原因不明
    0x100003f3f <+15>: movl   $0x1, -0x8(%rbp)		# 1 值写入变量 a，实际是写到栈内存中 rbp - 8 地址处
    0x100003f46 <+22>: movl   $0x2, -0xc(%rbp)		# 2 值写入变量 b，实际是写到栈内存中 rbp - 12 地址处
    0x100003f4d <+29>: movl   -0x8(%rbp), %edi		# 将 rbp - 8 地址处的内存值写入 edi 寄存器，即 1 写入 edi
    0x100003f50 <+32>: movl   -0xc(%rbp), %esi		# 将 rbp - 12 地址处的内存值写入 esi 寄存器，即 2 写入 edi
    0x100003f53 <+35>: callq  0x100003f10               ; sub at main.c:15
    0x100003f58 <+40>: movl   %eax, -0x10(%rbp)
    0x100003f5b <+43>: movl   -0x10(%rbp), %esi
    0x100003f5e <+46>: leaq   0x31(%rip), %rdi          ; "the return value is:%d\n"
    0x100003f65 <+53>: movb   $0x0, %al
    0x100003f67 <+55>: callq  0x100003f74               ; symbol stub for: printf
    0x100003f6c <+60>: xorl   %eax, %eax
    0x100003f6e <+62>: addq   $0x10, %rsp
    0x100003f72 <+66>: popq   %rbp
    0x100003f73 <+67>: retq   

```

我们重点讨论 a 和 b 两个入参的准备过程，对于 push，call 等，后面会再说。上面的 \<+4\> 到 \<+32\> 行是入参的栈填充过程，到了 \<+32\> 行，就开始正式调用子函数了。
首先，将 a、b 变量值写入栈的留置内存区域，而后将变量值从内存中读到寄存器中。这里的 edi 和 esi 寄存器就是用来传参的。
所以我们得到一种结论，即寄存器可以用来传递子函数参数。
但寄存器的数量是有限的，如果需要传递非常多的参数，是无法都通过寄存器来解决的，比如下面的例子：

```c
int sub(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o) {
  int t = a + b;
  return t;
}
int main(void) {
  int p = sub(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
  printf("the return value is:%d\n", p);
  return 0;
}
```

汇编如下：

```c
 `main:
    0x100003ee0 <+0>:   pushq  %rbp
    0x100003ee1 <+1>:   movq   %rsp, %rbp
    0x100003ee4 <+4>:   subq   $0x50, %rsp			# 预留 80 字节大小的栈内存空间
    0x100003ee8 <+8>:   movl   $0x0, -0x4(%rbp)		# 0 值写入，原因不明

    0x100003eef <+15>:  movl   $0x1, %edi			# 参数入 寄存器
    0x100003ef4 <+20>:  movl   $0x2, %esi			# 参数入 寄存器
    0x100003ef9 <+25>:  movl   $0x3, %edx			# 参数入 寄存器
    0x100003efe <+30>:  movl   $0x4, %ecx			# 参数入 寄存器
    0x100003f03 <+35>:  movl   $0x5, %r8d			# 参数入 寄存器
    0x100003f09 <+41>:  movl   $0x6, %r9d			# 参数入 寄存器

    0x100003f0f <+47>:  movl   $0x7, (%rsp)			# 参数入 栈内存
    0x100003f16 <+54>:  movl   $0x8, 0x8(%rsp)		# 参数入 栈内存
    0x100003f1e <+62>:  movl   $0x9, 0x10(%rsp)		# 参数入 栈内存
    0x100003f26 <+70>:  movl   $0xa, 0x18(%rsp)		# 参数入 栈内存
    0x100003f2e <+78>:  movl   $0xb, 0x20(%rsp)		# 参数入 栈内存
    0x100003f36 <+86>:  movl   $0xc, 0x28(%rsp)		# 参数入 栈内存
    0x100003f3e <+94>:  movl   $0xd, 0x30(%rsp)		# 参数入 栈内存
    0x100003f46 <+102>: movl   $0xe, 0x38(%rsp)		# 参数入 栈内存
    0x100003f4e <+110>: movl   $0xf, 0x40(%rsp)		# 参数入 栈内存

    0x100003f56 <+118>: callq  0x100003e90               ; sub at main.c:10

    0x100003f5b <+123>: movl   %eax, -0x8(%rbp)
    0x100003f5e <+126>: movl   -0x8(%rbp), %esi
    0x100003f61 <+129>: leaq   0x32(%rip), %rdi          ; "the return value is:%d\n"
    0x100003f68 <+136>: movb   $0x0, %al
    0x100003f6a <+138>: callq  0x100003f78               ; symbol stub for: printf
    0x100003f6f <+143>: xorl   %eax, %eax
    0x100003f71 <+145>: addq   $0x50, %rsp
    0x100003f75 <+149>: popq   %rbp
    0x100003f76 <+150>: retq   


```

可以发现，我这边测试环境下，传参超过 6 个，就需要写入栈内存。超出的部分，就不能通过寄存器传参了。

在上面有 a 和 b 两个变量的例子中，数据虽然也写到了 -0x8(%rbp) 和 -0xc(%rbp) 栈内存中，但那是因为 a / b 两个变量当前函数需要使用，不得不写入栈内存，如果像下面这样：

```c
int sub(int a, int b) {
  int t = a + b;
  return t;
}

int main(void) {
  int p = sub(1, 2);
  printf("the return value is:%d\n", p);
  return 0;
}

############

 `main:
    0x100003f30 <+0>:  pushq  %rbp
    0x100003f31 <+1>:  movq   %rsp, %rbp
    0x100003f34 <+4>:  subq   $0x10, %rsp
    0x100003f38 <+8>:  movl   $0x0, -0x4(%rbp)
    0x100003f3f <+15>: movl   $0x1, %edi		# 直接写入 edi 寄存器，不在写入栈内存
    0x100003f44 <+20>: movl   $0x2, %esi		# 直接写入 esi 寄存器，不在写入栈内存
    0x100003f49 <+25>: callq  0x100003ef0               ; sub at main.c:15
```

这里就很清晰了，1 和 2 两个参数，都是直接写入寄存器中的，不会再写到栈内存中。

对于 `sub(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) `的子函数调用，栈内存如下：
![][image-2]

备注1: 
大家看到栈内存里面，从上往下的内存顺序正好和我们代码里面的顺序是反的，这是 Mac + X86 环境。不同环境下这个规则是不一样的，有些环境下先写的参数会在上面。
备注2:
当前 7-15 的入参，是在当前函数栈里面存储的。即子函数执行完毕后，当前函数栈依旧保存这些入参。我觉得这个是不依环境改变的规则，有些博主写到子函数完成后这些入参也会释放，其实是不正确的。

## 子函数被调用

通过 call 指令即可完成函数帧的切换，即可以正常调用子函数了。上面例子中`callq  0x100003e90 ; sub at main.c:10 `即表示子函数跳转。
在调用子函数前，需要完成两个工作。
首先是当前指令的下一行指令地址（即 ip 寄存器的值）需要存入栈内存，为了在子函数执行完毕后可以继续执行下去。
其次是需要将子函数的函数内存地址(代码区)放入 ip 寄存器，这样 CPU 才能去执行子函数。

而这两个操作都是在 call 指令中完成的，所以 call 指令实际上等同于下面操作：
```c
pushq %rip
movq <子函数内存地址> %rip
```

对于 `sub(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) `的子函数调用，栈内存如下：

![][image-3]

这里再说明一下，为什么要先把 ip 程序寄存器的值写入栈内存，然后又写入新的值进去。
因为 ip 程序寄存器的本质工作就是不断执行下一条指令。如果当执行到 call 指令的时候，ip 寄存器里面已经存储了下一条指令的地址，即`0x100003f5b`。所以直接把 ip 寄存器入栈即可，即`pushq %rip`。
入栈后，因为要去执行子函数，所以需要把子函数的内存地址写入 ip 寄存器，这样 CPU 才会去执行子函数。即 `movl 0x100003e90, %rip`。

这里还有一个隐藏的点，即 rsp 寄存器变化了。原先指向`入参0x7`的，这个时候就指向`下一条指令的地址 ，即 0x100003f5b`。rsp 之所以能够变化，是因为`pushq %rip `指令会改变 rsp 的指向，下面会说到。

## 子函数执行中

这里就是重点了，rbp 和 rsp 有非常大的用途。也是函数调用栈的核心。

## 子函数执行结束后


## 父函数继续执行

[image-1]:	https://s1.ax1x.com/2022/03/21/qm8X6J.png
[image-2]:	https://s1.ax1x.com/2022/03/21/qmGl9S.png
[image-3]:	https://s1.ax1x.com/2022/03/21/qm8xmR.png