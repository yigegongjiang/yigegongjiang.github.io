---
title: 内存分配详解-由底到高
date: 2019-02-26 19:04:53
categories:
- 技术
tags:
-  计算机原理
-  C
-  内存
keywords: 计算机原理,内存分配,内存分区,比特,字节,指针,指针的指针,32位,64位,内存条,4G,8G
---

### 一行代码引发的思考
> int a = 5;

问1:变量a在内存的哪里？
问2:数字5在内存的哪里？
问3:int的字节大小是多少？如果a=12345后，字节大小变不变？
问4:代码里面print("%d", a)，为什么可以输出5，a是怎么找到5的？
问5:内存到底在哪里？
问6:总内存有多大？
问7:总内存的大小是怎么确定的？

各位能回答上面的7问吗？

由底往上来解析，一步一步揭开洋葱的外衣，真相终究会大白于天下！

<!-- more -->

### 字节与比特

比特这玩意，说好理解，马上能理解。说难理解，那肯定还是需要一翻思考总结的。
`比特是计算机存储的最小存储单元`。我们认知到的数字`3`，在计算机的存储里（硬盘或者内存）的结构是这样的：`00000011`。是的，也就是我们理解的二进制。
所以这个数字`3`是由8位组成的。每位有`0`和`1`两种变化。
恐怖的是，比特存储，是计算机的基石。我们在互联网上通行的一切，如图片、音视频、文字，甚至各位的博客、App、电子书等等，能想到的能通过互联网传输的一切，都是比特存储。
举个例子，我们看的一张图片，在磁盘上的存储，或许就是这样子：`0101011101010101010111101011110101010101100***(省略100000000个)***1010100111010101`。
所以，祝各位每年的`1024节`快乐，因为我们的努力，世界才如此缤纷多彩 ：)

1字节(byte)=8比特(bit)
我们刚才说到的数字`3`，就是一个字节，在磁盘上就是`00000011`。（为了便于理解，实际可能是`00000000 00000011`，或者`00000000 00000000 00000000 00000011`）。
`1字节=8比特`，这个是定死的，开始就是这么玩的，也会永远的玩下去。

1KB = 1024B（2的10次方）
1MB = 1024KB（2的10次方）
1GB = 1024MB（2的10次方）
这里大家不要迷惑，为什么是2的10次方，而不是3的10次方，也不是2的15次方。
"就是这么规定的，爱玩不玩！"

具体怎么定的这个规则，肯定有原因，肯定也能查到历史。具体各位在自行查看中外文档吧，查到了也请告知。

### 计算机基础与位的进化史

这里说计算机/手机的两个层面，一个是内存条，一个是CPU。

#### 内存条
实实在在的东西，有4GB、8GB、16GB等大小，长条形的带黑边的玩意，实体店网店都能买到，笔记本的小一些，台式机的大一些，有各种型号。手机的内存条是出厂固定在里面的，不好弄。
插到计算机的主板上面就能使用了。如果电脑开机的时候出现`滴滴滴`的声音，就把内存条拔出来檫檫，有很大概率能好。
**内存条根本性决定了我们可用的最大内存。**如果内存只有一个G，不管CPU和操作系统怎么高配，也只有一个G的内存能用。

内存条是硬件存储设备。它随随便便就能支持8GB的数据存储。各位知道8GB是多大吗？8GB = 8G \* 1024M \* 1024K \* 1024Byte，也就是`8589934592`Byte(字节)。
再恐怖点，1Byte=8Bit，Bit才是最小存储单元，所以真实存储是：`8589934592 * 8`即`68719476736`Bit（比特）。

#### CPU
**CPU一定程度上影响了最大内存，但不是根本原因。**
我们经常说的32位操作系统或者64位操作系统，说的是啥呢？其实说的是CPU里面核心的寄存器！寄存器是由多个**集成电路元件IC**组合成的。CPU上有数据总线的针脚，可以和内存条一一对应。如果CPU的数据总线有32个针脚，并且和内存条上面的32个数据总线针脚一一对应连接，那么就可以一次进行32比特的数据传输，也就是一次4个字节。那数据在CPU和内存双向流动的帮手是谁呢？没错，就是寄存器。所以寄存器也要有一次处理32比特数据的能力，所以这个时候寄存器也是32位的。
CPU中的寄存器决定我们的操作系统是`32位`还是`64位`（甚至8位，16位等）。这里的`32位`和`64位`，指的是寄存器的位数，而非内存地址的长度。因为从上面的分析我们可以看到，寄存器关心的是数据互通，没有和内存地址强制关联。寄存器位数越大，那么一次处理数据的能力越强。比如32位寄存器一次可以处理4字节数据，64位寄存器一次可以处理8字节数据，就是这么一个道理。


指的是`内存地址`的`位数`，因为寄存器存放的有内存地址。

#### 主板-地址总线
上面我们说的CPU一定程度上影响最大内存，但不是根本原因。原因就在于，CPU的核心是通过数据总线和内存条进行数据互通。他影响不了**内存空间**，影响的是**数据**。
那影响内存空间的是什么？是**地址总线**。**地址总线硬件决定了我们可用的最大内存。**
在CPU和内存条上，都有两个线，一个是数据总线，一个是地址总线。因为CPU和内存条本质也不是互通的，他们都需要插在主板上面，所以主板是他们沟通的桥梁。
主板上面也有数据总线和地址总线，但可以不做分析，他们线的数量可以不一样，只有相互连接的才是有效的，非连接的就是无用的。我们单独分析CPU和内存条的地址总线就可以了。

上面我们说到8G的内存条，有68719476736比特的数据，逆过来分析一下：
这么大的比特数据，在内存条是按照8Bit一组排列的。
每8Bit形成一个小房间。所以8GB的内存条里面，有`68719476736 / 8`个房间。
计算机操作系统可以通过`定向寻址`的方案，直接找到每个房间。形象来说，就是每个房间都有一个`内存地址`,系统通过`内存地址`就可以一瞬间biu～一下就到那个房间，房间里面有8个小人(8Bit)。

`内存地址`是关键，他是什么东西？
就是刚才我们说到的地址总线。如果地址总线有32条，那么`内存地址`最小为：`00000000 00000000 00000000 00000000`，最大为：`11111111 11111111 11111111 11111111`。64条就`00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000`和`11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111`。
对于32条地址总线来说，这最小和最大之间，有多少个呢？因为每个Bit有`0`和`1`两个选择，所以总共有2的32次方个。每一个都一一对应内存条里面的一个房间，所以最多可以对应`2*2*2*2(32个2相乘)=4294967296`个房间。
每个房间是8Bit即1Byte(字节)，也就是总房间大小为:`4294967296Byte`，也就是`4294967296Byte/1024K/1024M/1024G = 4GB`。
**真相开始大白了，对于32条地址总线，最大的内存地址也就是：`11111111 11111111 11111111 11111111`。也就是最多只能找到`2*2*2*2(32个2相乘)=4294967296`个房间。也就是最大内存查找范围只有`4294967296Byte/1024K/1024M/1024G = 4GB`。**

#### 数据总线和地址总线的关联
上面说了数据总线和地址总线，我们知道了数据总线用来传输数据，地址总线用来定位地址。
数据总线和地址总线的数量是不固定的，比如window操作系统，32位，那么数据总线是32条，而地址总线可能是32条，也可能是36条。
如果地址总线是32条，那么最大内存就是4G，如果有36条，那么最大内存就是64G了。所以大家一定不要迷惑，不是32位的操作系统最大只能支持4G内存条，像国家研究院里面的高配电脑，如果是32位，却被4G内存限制死了？不可能的。特殊使用的高配电脑都是上百G内存的。

如果32位数据总线，配36位地址总线，那么一次只能传输32位数据，数据对应的地址却是36位，寄存器这样看存不下来嘛，因为寄存器少了4位。不用担心的，操作系统操作两次就好了。
如果64位数据总线，配36位地址总线，那么一次能传输64位数据，而数据对应的地址却只有36位。这样只要把高位补0就可以了，这也是为什么64位操作系统能够兼容32位软件的原因。虽然浪费了空间，但是能兼容。
64位数据总线配64位地址总线？2的64次数，实在太大了，就是ipv6的数量。所以根本配不了64条地址总线，就是配了，也没有这么大的内存可以叠加啊。所以一般都配40-50条地址总线就差不多了。

#### 初步总结
原理分析完了，各位就知道一个现象了：
当年win7系统，明明买了8G的内存条，到`我到电脑`里面一看，只有4G不到。其余到4G不见了。
其实不是不见了，它还在那里，只是地址总线只有32条，导致读取不了更多到内存空间了。

### 指针

万物皆为C。即C语言。
后面孩子孙子辈的语言，尽管百花齐放，终究逃离不了指针。这是计算机发展史上的根基。

指针是什么？我理解的指针，就是存储一段数据，这个数据是什么？是`内存地址`。

```
int main(int argc, char *argv[]) {
    int a = 5;
    int *p = &a;
}
```

上面代码中，如何通过p找到5？

5是int类型的数据，所以在32位的内存条中这样存储：`00000000 00000000 00000000 00000101`。它占据4个房间。
a是什么？a是给我们程序员看的。代码编译后，目标文件进行分段存储。a是符号，就是5的`内存地址`，所以a就是连续的4个房间的首个内存地址，第一个房间的`内存地址`是：`00000000 00000000 11111111 11111111`(我假设的)。后面三个房间分别二进制+1。通过第一个房间，就可以连续的找到`5`这个存储数据。
p呢，指向a的指针，所以系统在内存里面存储了`00000000 00000000 11111111 11111111`这个二进制数据，也就是把a的`内存地址`给存了下来。同时这个二进制数据也有自己的连续房间号内存地址：`00000000 11111111 11111111 11111111`(我假设的）。这个地址，就是p啦。
p如何找到5？就是p通过存储的a的内存地址，找到了`5`的第一个房间号，都找到房间号了，肯定也就找到5这个存储数据了。
那为什么p刚好找到4个房间，而不是找到6个或者10个房间呢？int *p，这个就是关键，指针也是有数据类型的，p指针是int类型，大小也只有4字节。

### 指针的指针

```
int main(int argc, char *argv[]) {
    int a = 5;
    int *p = &a;
    int **pp = &p;
}
```

各位看，这里又创建了指向p指针的指针。啥意思？就还是指针。只不过这个指针，指向的不是5这个数据，还是另一个指针。那`int ***ppp = &pp`呢？还是一样的，还是指针，这个指针指向pp的内存地址。

所以这个时候，系统在内存里面存储了`00000000 11111111 11111111 11111111`这个二进制数据，也就是把p的`内存地址`给存了下来。同时这个二进制数据也有自己的连续房间号内存地址：`00001111 11111111 11111111 11111111`(我假设的）。这个地址，就是pp啦。

指针的指针的指针的指针，也还是一样的逻辑。`int **********pppppppppp = &ppppppppp`。

### 内存分配

各位看到了，内存分配的本质，就是`内存地址`的存储和调用。
我们的代码，在经过`预编译、编译、汇编、链接、挂载`一系列操作后，才能够从代码变成寄存器里面的二进制进而运行起来。
而我们运行的二进制文件，是一个分区清晰的二进制。我们的变量的定义，如果没有在预编译和编译环节被忽略外（编译环节会优化代码），都会整齐的通过一个方式放置于二进制文件的一个分区中（细了考量很复杂，详见《程序员的自我修养》）。
每一个变量，在程序编译后，就不客观存在了，使用的是这个变量所对应的`内存地址`。我们通过`内存地址`找到对应的数据，或者通过`内存地址`找到上一个`内存地址`，并最终找到对应的数据。
总内存条很大，所以里面分了几个大区。如堆栈等，还有高低位的限制。总体来说，内存是按照一定的顺序进行存储的。
我们使用的那些字面量啊或者对象啊啥的，就是一块存储区域。操作系统（栈）或者我们自己（堆）在内存区里面创建了这个数据并存储了下来。因为数据存储在房间里，所以每个数据都有一串连续的房间号（内存地址）。
在指针的逻辑里面，我们赋值等操作的时候，就是把这个内存地址，不断的放在另一个内存区域里面进行记录，然后读取的时候一环一环的就读取到了最终存储房间。

### 内存分区

内存分区有多种，如堆、栈、静态区、全局区、代码区等。上面的理解了，这些都只是外部包装，虽然他们本身很复杂，但是理解起来会简单的多了。因为我也只是理解，就不夸夸其谈了。自行Google。
特别推荐《程序员的自我修养》这本书，道尽了代码是如何运行起来的。

___

C绝对是计算机语言的开荒基石。
熟练C的程序员，大脑里就有一片星辰大海。