---
title: 内存分段与分页
date: 2022-02-08 23:46:11
categories:
- 技术
tags:
- 计算机原理
keywords: 内存,分段,分页
---

最近N刷了极客时间里面的《深入浅出计算机组成原理》，还是有很多收获。收获到不是新知识，更多的是复习稳固旧知识。时间长了，很多知识点就越来越淡忘，愚人，就多刷两遍加强记忆。
然后就在LMOS的文章里不知道看到了啥，反正看到了内存分段。这块我之前也都看过，在王爽的《汇编语言》和俞甲子的《程序员的自我修养-链接装载与库》中也都查看理解过。我本着复习一下的态度，就多刷了几个google关键词，就发现我之前倒是对内存分页有了解，而内存分段其实是不成体系的。
刷了一段时间，把书和相关专栏查看一遍，颇有收获，想着记录下来，也给其他人参考。

## 0x01 内存蛮荒时代

在8086芯片被intel破土成功的时候，内存是被程序员直接控制使用的。那时候也没有虚拟内存、MMU、分页等等这些概念。简单来说，那时候内存控制是低级别控制，得开发人员自行汇编控制。
8086的硬件配置是数据总线宽度16、地址总线宽度20。而寄存器的位数一般都是和数据总线宽度相同，即16位寄存器。
> 数据总线用于寄存器和内存互传数据，16根总线表示同一时间内可传递2个字节。
> 地址总线用于随机指定内存地址，20根总线表示可指令内存范围为0-2^20kb(1M)。
> 控制总线用于CPU向外部发送控制命令，比如向内存发送读(load)或者写(store)命令。
所以这时候就会有个问题，向内存地址总线传递的地址如果直接从寄存器来，那么范围不够。16位寄存器只能确定0-2^16kb(64kb)的内存空间范围，64kb-1M的空间都只能被浪费掉。这显然是不行的，所以intel想了一个办法，增加了4个段寄存器，分别是cs、ds、ss、rs。通过cs:ip两个寄存器来确定pc寄存器的地址，及cs*16+ip。其他段寄存器也是一样的计算方式。这样就通过段寄存器*16+偏移量的方式，增加到20位，也满足了20根地址总线的最大内存检索范围。我考虑过，如果真的只用一个段寄存器，也是可以实现代码段、数据段、栈段、其他段的复合类型的，但显然没有这么做，而是用了4个段寄存器分别表达。
这里就是“内存分段”的蛮荒时代了，因为这里就已经内存分段了。内存分段的意思，就是将一个程序通过“代码段”、“数据段”这样的分区间方式给隔离开。
这时候的隔离还是比较粗暴的，即芯片并没有强制规定cs一定用于代码段(这也是上面我说的只用一个寄存器也能实现的原因)，所以本质上来说，这时候的分段比较混乱，段寄存器更多的用于16位寄存器和20根地址总线之间的不协调的适配。

## 0x02 青铜-分段

## 0x03 砖石-分页

## 0x04 分段分页