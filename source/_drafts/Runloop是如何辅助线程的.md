---
title: Runloop是如何辅助线程的
date: 2020-05-06 18:57:05
categories:
- 技术
tags:
- iOS
---

现在的操作系统，线程是最小的执行单元。一个程序，操作系统开启进程进行资源分配后，通过线程的函数执行调用栈进行机器码的执行。
多线程是为了提高效率，没有多线程，程序是依旧可以执行。那么，抛开多线程来说，**单线程的函数执行调用栈，如何完成异步操作？**
比如，Javascript，是单线程的语言，如果做定时器功能？
比如，iOS，如何在主线程实现`dispatch_async(dispatch_get_main_queue(), ^{});`异步功能？

单线程，只有一个调用栈，同一时间只能执行一段连续的机器码。
程序=执行+数据，程序执行就是不间断的函数调用。
我们开发的时候基本上写的都是同步的函数调用，比如A函数里面调用B函数，而A函数又是被main函数调用的，main函数本身又是一个地址，被`call`后执行。
这样，我们已经写好的固有顺序的机器码就可以依次执行完毕，就像C语言一样，我们在main函数里面写上一些代码，再通过传参调用n个func，最后执行`return 0;`结束整个程序。
那异步其实和同步一样，大家都是函数，都是一个地址，只是被`call`的时间不一样。
比如下面伪代码：
```
func b() {
	printf("func b is called.\n");
}
int main() {
	int m = 1;
	sync:b();
	async:b();
	int n = 2;
}
```
上面的代码中，
如果b函数的调用是同步，那么n的赋值指令，一定是在b函数指令全部执行完毕后，才能执行。
> 注意这里的描述，“int n = 2;”这行代码，一定是b()调用完毕后，才能执行。但是，b()却不一定是"int m = 1;"这行代码执行后就立刻执行的。比如：“dispatch_sync(queue, ^{printf("hello\n");});”，这里打印hello同步任务，需要等到queue队列里面已有的任务出队后，才能执行。如果当前queue里面已经有一个需要执行10s的同步任务，那么10s后hello才能打印。所以同步代表的是“之后的指令”需要“当前的指令“执行完毕后才能执行，不代表”当前的指令“一定在”之前的指令“执行后执行。
如果b函数的调用是异步，那么b函数指令的执行，一定不在n的赋值操作之前。
> 这个时候，b函数只要不在n的赋值操作前执行，都算异步，哪怕n的赋值指令刚好执行一半，然后执行了b函数，也算异步。所以异步的执行时机是未知的。

我们写的基本都是同步代码，所以很好理解。而异步代码，我们也说了，执行时机未知，但一定会在未来的某一个时刻被执行。

那么单线程如何解决定时器及异步功能呢？显然，不好解决。直接原因有两点：
1. 调用栈执行完固有顺序(同步)的机器码后，线程就没事做了，这个时候线程就销毁了，上面的“C语言return 0后会结束整个程序”就是一个例子。这个时候定时器要求“n秒后需要执行的func”，根本来不及执行，因为整个程序都结束了。
2. 调用栈只有一个，都在按部就班的执行一段机器码(同步)，PC指令寄存器不断的next下一个指令地址并执行。异步的入口函数地址，插不到正在执行的调用栈中去。举例来说：如果线程现在正在执行A函数，或者正在执行一个1000000次的for操作，A函数和for操作的机器码都已经固定了，异步入口函数的`call 0x7543674`指令，怎么也插不进去。插不进去，异步函数就无法执行。

这样看来，单线程执行异步操作，目前被两个点限制住了，一个是线程具有生命周期，执行完固定数量的指令后，线程就要被销毁了，异步操作来不及执行。一个是指令调用栈只有一个，正在执行同步代码呢，没有一个很好的契机去执行异步代码。

如何解决单线程下的异步操作呢？
实际上有一个异步方案是比多线程还早提出来，那就是协程。协程就是基于单线程的多并发操作。目前协程已经在很多语言上大放异彩，如Go，Python。
协程的方案就是，虽然指令调用栈只有一个，但是语言层面可以模拟多个。在内存中保存多个调用栈的上下文，这样就可以跳到任意一个调用栈中执行。
比如当前线程在a调用栈执行A函数，有一个1s后的定时器在B函数。线程在1s后，保存a调用栈的上下文，切到b调用栈执行B函数，执行完后，再恢复a调用栈继续执行A函数。这样，就可以在单线程里面做N个定时器这样的异步操作。
实际上，这个N，轻轻松松到几十万没有问题。协程的异步高并发方案比多线程的性能要高很多，因为线程的上下文切换很耗CPU。
协程主要用在I/O阻塞的地方，比如数据库、网络等，他们相对CPU来说都是非常耗时的，需要n秒后才能拿到结果。依靠协程，就可以异步在n秒后处理拿到的数据。
协程是近几年才开始盛行起来的，毕竟前些年，互联网还不发达，数据库和网络的性能瓶颈，通过多线程就能够支撑，那时候网络使用没有现在复杂，多开一些线程就能满足并发需求。
协程对于I/O密集任务有很好的处理，当I/O处理完成后，有一个事件激活并恢复当前I/O所在的线程调用栈，执行完数据的业务处理后，再回到并恢复其他调用栈，一个异步就完成了。

但是我们项目开发中，需要的异步任务，一般还都不是I/O密集型，比如`dispatch_async(dispatch_get_main_queue(), ^{});`，它没有I/O密集，相反，它只需要在未来的某一个时间被执行就好。

实际上，有个非常厉害的程序设计，叫做“事件驱动(Event Driven)”。事件驱动的执行流程为：如果A事件需要处理，那么需要B事件去推动A事件。这里的事件，可以是一个动作，或者一个程序指令，或者一个端口信号。
比如，我们按下一个键盘，CPU会给我们一个响应。那么我们不按键盘呢？CPU要一直监听我们按键盘的动作吗？显然不会。所以这里就有一个事件驱动，即：我们按下键盘是一个动作，当键盘按下后，会发送电信号到事件总线，这个时候CPU知道有键盘被按下了，就开始读取缓冲区内容，看用户按下了哪个键。
而依据“事件驱动”这样形式的，通过某个事件推动另一个事件的执行，就是单线程异步方案的一个实现。
用JavaScript里面的`setTimeout(()=>{console.log('hello')}, 0)`举例，虽然延时为0，但这也是一个延时操作。语言层面会基于“事件驱动”思想，建立一个队列，然后把异步需要执行的操作(函数地址)都放到队列里面。当线程处理完当前的任务后，会去查看队列里面是否还有需要执行的任务，发现有一个任务，就将这个任务出队并执行。我们不需要特别记忆有这么一个异步任务，只需要在线程空闲后，去查询一下队列，发现里面有任务，就拿出来执行就好。
上面的`dispatch_async(dispatch_get_main_queue(), ^{printf("hello\n");});`也需要一个契机被执行。现在，我们正在执行一个任务，CPU在马不停蹄的运转着。那`printf("hello\n");`什么时候开始执行呢？时间很难确定，只能说，在一个合适的时间会被执行。比如下面场景：
```
- (void)random_time_to_run {
	dispatch_async(dispatch_get_main_queue(), ^{
		printf("hello\n");
	})
	int n = 1000000;
	for (int i = 0; i < n; ++i) {
		printf("nothing todo\n");
	}
}
```
这里，有一个1000000的循环，这个循环可能需要10s才能执行完毕，然后才能执行`printf("hello\n");`。如果n=1，那可能0.0001s之后就可以执行`printf("hello\n");`这个指令。
正因为`printf("hello\n");`执行时间的不确定，所以我们就需要有个方案，在特定的场景下，可以执行它。准确来说，在某个事件到来后，就去执行它。
iOS里面，就把GCD的主线程异步操作，封装到一个事件循环里面。




而“事件驱动”，也不仅仅可以完成异步方案这么一个功能。





那么，如果要解决上面提到的异步操作功能，单线程顺序执行机器码就无法完成了，这个时候有两个线程限制需要解决：
1. 线程是具有生命周期的，我们写好的固有顺序的机器码执行完后，线程就没有事情干了，这个时候线程最终会被销毁。

线程和函数调用栈关系
异步操作如何以及合适在单线程中调用并执行
runloop和eventloop的关系
runloop原理分析
runloop应用
