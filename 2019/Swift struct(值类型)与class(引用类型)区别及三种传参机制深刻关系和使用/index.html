<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="null//null" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.yigegongjiang.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.11.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"text":"Current boards are better for light mode to discuss. Dark mode click here -->","order":-2},"utterances":{"text":"Dark mode","order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。 因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objec">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用">
<meta property="og:url" content="https://www.yigegongjiang.com/2019/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="一个工匠">
<meta property="og:description" content="在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。 因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objec">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMdxO.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EM2JP.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMgit.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EM6II.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMDqH.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMsZd.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMBse.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EM5LQ.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMRRf.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMhQS.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/11/8EMWz8.png">
<meta property="article:published_time" content="2019-12-19T16:00:00.000Z">
<meta property="article:author" content="隔壁王二">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/03/11/8EMdxO.png">


<link rel="canonical" href="https://www.yigegongjiang.com/2019/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.yigegongjiang.com/2019/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/","path":"2019/Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用/","title":"Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用 | 一个工匠</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="一个工匠" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="一个工匠" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">一个工匠</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">跋山涉水，走心为匠。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags<span class="badge">11</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives<span class="badge">47</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0X00-struct%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A5%BD%E5%83%8F%E5%9C%A8%E5%93%AA%E9%87%8C%E8%A7%81%E8%BF%87%EF%BC%81struct%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X01-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B7%AE%E5%BC%82"><span class="nav-number">2.</span> <span class="nav-text">0X01 值类型和引用类型的内存差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text">引用类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">值类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.</span> <span class="nav-text">值类型和引用类型内存比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X02-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E5%B7%AE%E5%BC%82"><span class="nav-number">3.</span> <span class="nav-text">0X02 值类型和引用类型的相等性差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.</span> <span class="nav-text">值类型相等性比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83"><span class="nav-number">3.2.</span> <span class="nav-text">引用类型相等性比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X03-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E8%8A%B1%E5%BC%8F%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">4.</span> <span class="nav-text">0X03 值类型和引用类型在花式传参过程中的异同</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E5%8F%82%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82"><span class="nav-number">4.1.</span> <span class="nav-text">值类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E5%8F%82%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82"><span class="nav-number">4.2.</span> <span class="nav-text">引用类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%B1%E5%BC%8F%E4%BC%A0%E5%8F%82%E6%80%BB%E7%BB%93"><span class="nav-number">4.3.</span> <span class="nav-text">花式传参总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X04-%E5%80%BC%E8%AF%AD%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E8%81%94%E5%8A%A8%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">0X04 值语义和引用语义的联动性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X05-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E7%BA%A7%E5%B7%AE%E5%BC%82"><span class="nav-number">6.</span> <span class="nav-text">0X05 值类型和引用类型的抽象层级差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X06-struct%E5%92%8Cclass%E8%81%94%E5%8A%A8%E5%86%85%E5%B5%8C%E4%B8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5"><span class="nav-number">7.</span> <span class="nav-text">0X06 struct和class联动内嵌下的认知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">值类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">值类型嵌套引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">引用类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.4.</span> <span class="nav-text">引用类型嵌套引用类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X07-Swift%E4%B8%AD%E7%9A%84struct%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E7%89%B9%E5%88%AB%EF%BC%9Fstruct%E8%83%BD%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E8%AE%A4%E7%9F%A5%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OX08-Swift%E4%B8%8BString%E7%9A%84%E6%90%85%E5%B1%80%E8%AF%AF%E5%8C%BA"><span class="nav-number">9.</span> <span class="nav-text">OX08 Swift下String的搅局误区</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隔壁王二"
      src="https://s1.ax1x.com/2020/05/05/Yi9cuQ.gif">
  <p class="site-author-name" itemprop="name">隔壁王二</p>
  <div class="site-description" itemprop="description">跋山涉水，走心为匠。而时间，却真的不多了。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.yigegongjiang.com/2019/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s1.ax1x.com/2020/05/05/Yi9cuQ.gif">
      <meta itemprop="name" content="隔壁王二">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个工匠">
      <meta itemprop="description" content="跋山涉水，走心为匠。而时间，却真的不多了。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用 | 一个工匠">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-20T00:00:00+08:00">2019-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。<br>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。</p>
<p>因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objective-C里面的NSString，它是引用类型，但是我们却在使用它的值语义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *oldname = @&quot;hello&quot;.mutableCopy;</span><br><span class="line">NSMutableString *newname = oldname;</span><br><span class="line">newname = @&quot;word&quot;.mutableCopy;</span><br><span class="line">NSLog(@&quot;\n oldName:%@ \n newName:%@&quot;, oldname, newname);</span><br><span class="line"> </span><br><span class="line">&gt; oldName:hello </span><br><span class="line">&gt; newName:word</span><br></pre></td></tr></table></figure>
<p>我们使用了引用类型的NSMutableString，但是newname并没有引用复制oldname，仅仅是指针地址复制了oldname。这样导致了newname并不是oldname的别名(alias)。<br>如果newname是oldname的别名，那么对newname的所有all操作，都会同步到oldname。<br>这里，newname如果改变了对象数据是可以同步到oldname，但是却不能改变oldname变量的值（oldname的存储值，即“hello”的指针地址）。<br>所以，这里的NSMutableString虽然是引用类型，却具有值语义。</p>
<p>因为编程语言概念上的模糊，下面首先介绍struct和值类型的关系。<br>然后重点说明值类型和引用类型的区别，这是重点，直接解释了struct和class的根本区别。<br>最后加一点小彩蛋，介绍Swift里面struct特性。</p>
<span id="more"></span>

<h3 id="0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？"><a href="#0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？" class="headerlink" title="0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？"></a>0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？</h3><p>好久好久之前，是没有class什么事的。那时候C语言活跃于各种应用场景，在上层抽象了汇编的实现，C语言可以用于嵌入式、服务器、驱动等。为什么没有class什么事情？class是类，是OOP（面向对象编程&#x2F;对象导向编程）的专属。而C语言是过程式语言，没有对象概念，也就没有class什么事情。<br>那时候，都用结构体，也就是struct。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// C语言版本</span><br><span class="line">// 人员结构体，具有姓名和年龄</span><br><span class="line">struct Person &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那时候，这些数据都叫做<strong>值类型</strong>，而struct就是值类型的。值类型是<strong>变量直接包含值</strong>统称，其他的还有基础数据类型，如Int，long，char，bool，以及自定义struct（如上面的Person）。<br>后面大家就知道了，出现了C++&#x2F;Java&#x2F;C#等OOP语言，class开始活跃于千万家。更甚之，在某些语言上，值类型已经被淡化了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Objective-C版本 .h</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line">@property(nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以上为OC的版本，我们会这么描述它：我们创建了一个Person类。他具有名称属性和年龄属性。<br>而且，我们也确定，如果我们新建一个Person对象,如<code>Person *p = Person.new;</code>，那么这个对象一定存放在堆内存。那我们为什么不能把对象创建在栈内存呢？<br>我们可以知道，上面OC创建的是Class，对象存在于堆中。那我们可不可以把对象放在栈上？至少在Objective-C开发过程中，肯定不会想到这个，因为struct&#x2F;结构体&#x2F;值类型被淡化了。（Java也是一样，号称纯OOP语言）<br>其实我们可以创建栈上的数据的，如局部变量中的Int、long等，都是在栈上的。说一个少见的，CGRect、CGSize也是在栈上的。源码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* Points. */</span><br><span class="line">struct</span><br><span class="line">CGPoint &#123;</span><br><span class="line">    CGFloat x;</span><br><span class="line">    CGFloat y;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGPoint CGPoint;</span><br><span class="line"></span><br><span class="line">/* Sizes. */</span><br><span class="line"></span><br><span class="line">struct CGSize &#123;</span><br><span class="line">    CGFloat width;</span><br><span class="line">    CGFloat height;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGSize CGSize;</span><br><span class="line"></span><br><span class="line">/* Rectangles. */</span><br><span class="line"></span><br><span class="line">struct CGRect &#123;</span><br><span class="line">    CGPoint origin;</span><br><span class="line">    CGSize size;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGRect CGRect;</span><br></pre></td></tr></table></figure>
<p>其实OC中使用的CGRect等，也就是struct值类型数据。只是我们很少顾及值类型，虽然一直用，但是感知不到他们的存在。<br>直到有一天，Swift也成了苹果开发的官方语言，引入了struct，一大堆开发人员开始迷惑，发生了什么事？我该怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的Person，一个是struct，一个是class。一个复制的时候是全部数据复制，一个复制的时候是指针复制。一个有可能存放在栈上，一个只能存放在堆上。<br>放心了很多，原来struct和Int、BOOL等是一样的。他们本身不可以改变，只能被复制。struct拥有和Int一样的外观。<br>等等，Swift的struct可以引入方法，可以实现构造器，甚至可以通过mutating来改变自己。俨然已经上升可以和class平起平坐了（其实没有高低之分）。这怎么和Int又不太一样了？struct到底是啥？</p>
<p>其实struct一直都没有消失。它一直在我们周边。仅仅是因为我们在个别面向对象语言的冲击下，淡化了值类型。<br>而现在，在Swift中，我们必须捡起来，因为值类型在Swift中不可或缺了。甚至Swift里面的Int,String等，都是通过struct直接实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// A signed integer value type.</span><br><span class="line">///</span><br><span class="line">/// On 32-bit platforms, `Int` is the same size as `Int32`, and</span><br><span class="line">/// on 64-bit platforms, `Int` is the same size as `Int64`.</span><br><span class="line">public struct Int : FixedWidthInteger, SignedInteger &#123;</span><br><span class="line"></span><br><span class="line">    /// A type that represents an integer literal.</span><br><span class="line">    public typealias IntegerLiteralType = Int</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，C++一直存在值类型，而且C++里面的自定义的struct还可以继承和多态，完全面向对象化了。</p>
<h3 id="0X01-值类型和引用类型的内存差异"><a href="#0X01-值类型和引用类型的内存差异" class="headerlink" title="0X01 值类型和引用类型的内存差异"></a>0X01 值类型和引用类型的内存差异</h3><p>值类型和引用类型，从语法上还是毕竟容易理解的。如果牵涉到语义，就比较复杂，因为上面说到的，引用类型就牵涉到了值语义。<br>我们先从语法上来理解值类型和引用类型的内存差异。</p>
<h4 id="引用类型内存图"><a href="#引用类型内存图" class="headerlink" title="引用类型内存图"></a>引用类型内存图</h4><p>首先，class是引用类型，一定是存放在堆内存上的。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: UInt8?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">&gt; person.name:Robot</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></table></figure>
<p>那么我们定义一个Person对象时候的内存分布如下图：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EMdxO.png" alt="swift_struct_class_引用类型"><br>person这个引用变量，我们使用的时候，可能存储在栈中的（也可能在堆中，但不是重点）。但是其指向的对象，却一定是在堆中的。</p>
<blockquote>
<p>这里我们有两个名词认知不要弄混了，一个是person变量，一个是person对象。变量只是符号，编译的时候存储于符号表中的一个标记，对象才是我们使用的数据实体，变量用于找到对象。someOne也是同理。下文中的变量和对象都是同理，后面不再做强调。</p>
</blockquote>
<p>上面操作完成后，person和someOne的name都变成Robot了，这是合情合理的，我们都司空见惯了，不做多描述。</p>
<h4 id="值类型内存图"><a href="#值类型内存图" class="headerlink" title="值类型内存图"></a>值类型内存图</h4><p>下面看看值类型，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = &quot;Robot&quot;</span><br><span class="line"></span><br><span class="line">&gt; person.name:Hello</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></table></figure>
<p>内存分布如下图：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EM2JP.png" alt="swift_struct_class_值类型"><br>我们可以发现，值类型相比引用类型，person和someOne这两个值变量，<strong>指向</strong>特征不那么明显了，更多的是复制。我们的someOne并没有指向person，而是把person的数据完全复制了一份成为自己的。<br>更重要的，person和someOne存储的，<strong>不再是对象的指针，而是真真实实的数据了</strong>。其实对象依旧还是对象，变量依旧是变量，如上面说的那样。但是，<strong>值变量，直接包含数据(值类型的定义)<strong>了，不再通过指针指向数据了。<br>当然，我们从图上看到的，值对象是在栈里面。当然值对象也会在堆里面，场景不一样，存储位置也会不一样。但是和引用对象不同的一点，</strong>值对象是可以存储在栈里面的</strong>。</p>
<blockquote>
<p>我们经常使用的Int等，其实很多时候都是存储在栈里面的。上面Person引用类，其实也有age属性，这个age属性就是值对象存储在堆上，因为person对象是在堆上的。后面说到struct和class联动内嵌的时候，会详细说明</p>
</blockquote>
<h4 id="值类型和引用类型内存比较"><a href="#值类型和引用类型内存比较" class="headerlink" title="值类型和引用类型内存比较"></a>值类型和引用类型内存比较</h4><p>显而易见，内存方式的不同，带来的优缺点也是迥异的。<br>最直接的，栈肯定是比堆快的。下面我们默认<strong>值对象存储在栈中，引用对象存储在堆中</strong>进行分析。<br><strong>一来</strong>，值类型通过值变量直接定位数据，而引用类型需要通过引用变量的指针间接获取，在寻址方面就会出现时间劣势。<br><strong>再者</strong>，栈通过CPU提供的指令寄存器操作数据，而堆通过操作系统支持。堆空间由程序员自行控制，包括垃圾回收等，CPU不会干预过多。<br><strong>其次</strong>，我们在栈上分配内存，是直接分配。而对于引用类型，只在栈上分配变量地址，对象需要另外分配堆内存空间。（可能会出现这种情况，需要100个对象，栈类型会在栈内存中直接分配完毕，而引用类型会在栈上一次性分配100个变量内存，然后在堆中需要进行100次对象内存分配。）<br><strong>而且</strong>，由于堆内存是空间不连续性的（操作系统分配堆内存池供开发使用，如果一个对象销毁了，就会产生内存碎片），不连续堆空间会违背局部性原理，会增加高速缓存错失的几率（命中不了）。堆空间的高速缓存指的是二级缓存，而栈是依据“LIFO”的存储机制，不会出现内存碎片，天然增加了一级缓存的命中率。<br><strong>特别</strong>，各种语言都会着重优化值类型，以达到更快的速度。毕竟栈处理速度的快慢，直接影响到程序的快慢。因为我们的代码运行根本依靠函数，而函数就是在栈中执行，如main函数和自定义函数。所以才会加入寄存器这样的快速单元，而堆里的数据，是可以通过异步来完成存储的。<br>因为值对象也是会存储在堆中，所以我们可以这样说：<strong>值类型有可能利用栈的优势，进一步提高程序的性能</strong>。</p>
<p>内存比较上，相比来说，值类型完胜引用类型。<br>引用类型相应的优点，<br>一来，发生在拷贝的过程中。值类型拷贝是完全拷贝，所有数据都会拷贝一遍，而引用类型，拷贝的仅仅是指针，从而提交效率。<br>二来，栈内存空间有有限的，相比堆内存空间，简直太小来，如著名的网站“Stack Overflow”的名字一样，动不动就会栈溢出。而堆内存，就是普通点的服务器，4G容量不是问题的，高级点的服务器都是几十几百G容量。<br>我们可以看出，栈和堆相比，强于速度，弱于空间。虽然速度完胜，但除了空间，还有其他方面，引用类型却又是完胜值类型的。从Java，Objective-C这些语言上不难看出，引用类型的确是完胜值类型的。下面我们一点点来分析他们之间的不同和场景应用。</p>
<h3 id="0X02-值类型和引用类型的相等性差异"><a href="#0X02-值类型和引用类型的相等性差异" class="headerlink" title="0X02 值类型和引用类型的相等性差异"></a>0X02 值类型和引用类型的相等性差异</h3><h4 id="值类型相等性比较"><a href="#值类型相等性比较" class="headerlink" title="值类型相等性比较"></a>值类型相等性比较</h4><p>我们回顾一些最基础的值类型Int的相等性比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 100</span><br><span class="line">var num2 = 100</span><br><span class="line">assert(num1 == num2)</span><br><span class="line">var num3 = 200</span><br><span class="line">assert(num1 != num3)</span><br></pre></td></tr></table></figure>
<p>上面代码编译运行，断言是可以通过的。值类型的比较，特别简单，就是比较数据是否一样。<br>因为值类型，不管存储在哪里，不变的一点是，值变量直接包含值对象。我们自定义一个值类型来看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person: Equatable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = &quot;Hello&quot;</span><br><span class="line">// someOne.name = &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">assert(person == someOne)</span><br><span class="line">// assert(person != someOne)</span><br></pre></td></tr></table></figure>
<p>它们的内存图如下：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EMgit.png" alt="swift_struct_class_值类型相等性"><br>当两个值对象的name都是Hello的时候，两个值对象是相等的。如果someOne的name变成Robot，两个值对象就是不想等的。（如果我们把注释的代码打开，相应注释位置上一行代码删除，会发现两个断言都是可以通过的。）<br>值类型的相等性比较真的非常简单，就是匹配字节码是否一致。只要值对象的所有字节码是一致的，那两个值对象就是相等的。字节码从哪里来？Hello和Robot，计算机不认识的，他们都会变成对应的码值然后转化成二进制存储内存中。所以值类型相等性判断就是查看二进制是否一样。</p>
<h4 id="引用类型相等性比较"><a href="#引用类型相等性比较" class="headerlink" title="引用类型相等性比较"></a>引用类型相等性比较</h4><p>因为引用变量存储的是引用对象的内存地址。同样一个对象，可能有两个引用变量存储着其地址。<br>所以引用类型的比较，有两个方面，一个是比较存储的内存地址是否一致，另一个是比较内存地址对应的数据是否一致。<br>因为字符串在Swift里面是值类型的，我们用Objective-C里面的NSString来分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 = [NSString stringWithFormat:@&quot;%@&quot;, @&quot;Hello&quot;];</span><br><span class="line">NSString *str2 = @&quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">assert(str1 == str2);   // ERROR</span><br><span class="line">assert([str1 isEqualToString:str2]); // OK</span><br></pre></td></tr></table></figure>
<p>相应的内存图如下：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EM6II.png" alt="swift_struct_class_引用类型相等性"><br>因为Objective-C对于字符串的生成比较考究（Objective-C里面，字符串根据创建的形式不同和存储中英文的不同，有常量区、栈区、堆区不同表现形式），我们用上面方式建立两个不同地址的Hello字符串。其中比较相等性，一个是通过**&#x3D;&#x3D;<strong>，一个是通过</strong>equal**。<br>引用类型的相等性比较，直接通过值类型的&#x3D;&#x3D;比较的化，比较的是内存地址，显然str1和str2，他们的内存地址不可能一样，所以他们并不相等。<br>而通过equal来比较，就变成了上面的值类型的字节码比较，Hello的二进制存储都是一样的，他们就相等了。</p>
<h3 id="0X03-值类型和引用类型在花式传参过程中的异同"><a href="#0X03-值类型和引用类型在花式传参过程中的异同" class="headerlink" title="0X03 值类型和引用类型在花式传参过程中的异同"></a>0X03 值类型和引用类型在花式传参过程中的异同</h3><blockquote>
<p>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。</p>
</blockquote>
<p>为什么三种传参方式对struct和class的理解如此重要？其实他们本不重要，只是附带品。但是因为很多很多人对他们认知是错误的，所以才变得重要起来。<br>毕竟，错误的理论，总不能推导出来正确的知识。<br>首先，我们需要确定一个知识点，<strong>值传参</strong>、<strong>引用传参</strong>、<strong>地址传参</strong>和<strong>值类型</strong>、<strong>引用类型</strong>相比，虽然也有<strong>值</strong>和<strong>引用</strong>的区分，但他们不一一对应的关系，即不是值类型对应值传参。<br>值类型和引用类型是数据存在的方式，三种传参方式，是数据传递的方式。他们是对数据两个层面的操作控制。<br>所以，我们总共有6种情况需要分析：值类型下的值传参、引用传参、地址传参，引用类型下的值传参、引用传参、地址传参。<br>说明：因为引用传参很多语言默认都没有实现，如Java、Objective-C、Swift等等,所以需要通过C++模拟。</p>
<h4 id="值类型下的值传参、引用传参、地址传参"><a href="#值类型下的值传参、引用传参、地址传参" class="headerlink" title="值类型下的值传参、引用传参、地址传参"></a>值类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的值传参</span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person: Equatable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = &quot;Robot&quot;</span><br><span class="line">someOne = Person(name: &quot;SomeOne&quot;, age: 18)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的地址传参</span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">func change(someOne: inout Person) &#123;</span><br><span class="line">    someOne.name = &quot;Robot&quot;</span><br><span class="line">    someOne = Person(name: &quot;SomeOne&quot;, age: 18)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">change(someOne: &amp;person)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的引用传参</span><br><span class="line">// C++ 版本</span><br><span class="line">void change(int &amp; param2)&#123;</span><br><span class="line">    param2++;</span><br><span class="line">    param2 = 100;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int param1 = 20;</span><br><span class="line">change(param1);</span><br></pre></td></tr></table></figure>
<p>上面的内存分布如图：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EMDqH.png" alt="swift_struct_class_值类型的三种传参"></p>
<p>我们分析一下值类型下的三种传参，</p>
<ol>
<li>值传参，就是行参对象原封不动的获取了实参对象的<strong>数据拷贝</strong>。两个对象之间不再有任何关联，对行参对象的内部修改(someOne.name &#x3D; “Robot”)和自身修改(someOne &#x3D; Person(name: “SomeOne”, age: 18))，都不会更改另一个对象的任何数据。如上图所示，person对象没有任何修改。</li>
<li>地址传参，就是行参对象原封不动的获取了实参对象的<strong>地址拷贝</strong>。所以行参实际存储的是实参的内存地址拷贝。那么通过内存地址对数据的内部修改(someOne.name &#x3D; “Robot”)都会影响到原对象，毕竟对象只有一个。但是行参自身修改(someOne &#x3D; Person(name: “SomeOne”, age: 18))，却不会影响到原对象，因为行参是实参的地址拷贝，自身数据的改变就是改变了拷贝的那份内存地址，不会影响到实参。<strong>所以地址传参，本质还是值传参，因为拷贝了实参的内存地址（而非整个对象数据）</strong>。而通过内存地址修改原数据，这是一种途径，和传参无关，因为内存地址本身就是用来获取和修改数据的。</li>
<li>引用传参，分析起来其实最简单的。那就是，行参仅仅是实参的一个别名(alias)。行参存储的依旧是实参的内存地址拷贝，但是对行参所有的操作，都会通过<strong>间接寻址</strong>的方式直接操作实参。注意，是所有操作，因为行参仅仅是实参的别名。所以我们看到，引用传参里面，行参不仅可以修改原对象数据，还可以更换原对象。(这个更换原对象，有两种方式，上图中是其中一种，即在原对象内部修改数据，没有创建新对象。还有一种方式是创建一个全新的对象，然后实参指向新对象，是以新换旧的思想。但是原理都不变，都是行参操作实参直接改变数据。)</li>
</ol>
<p>通过上面值类型的三种传参，大家可能已经发现，在Objective-C、Java、Swift里面进行值类型的实参行参赋值的时候，其实<strong>都只是值传参和地址传参，并没有引用传参</strong>。只有个别语言如C++里面才支持引用传参。<br>上面说明的是值类型，那么引用类型的三种传参是否会有一些不同呢？</p>
<h4 id="引用类型下的值传参、引用传参、地址传参"><a href="#引用类型下的值传参、引用传参、地址传参" class="headerlink" title="引用类型下的值传参、引用传参、地址传参"></a>引用类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型的值传参</span><br><span class="line">// Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; Person &#123;</span><br><span class="line">        return Person(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person.copy();</span><br><span class="line">person.name = &quot;Robot&quot;</span><br><span class="line">someOne.name = &quot;SomeOne&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型下的地址传参</span><br><span class="line">// Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne = person;</span><br><span class="line">person.name = &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">someOne = Person(name: &quot;SomeOne&quot;, age: 18)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型下的引用传参</span><br><span class="line">// C++ 版本</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    Person(char *temp, int flag);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Person::Person(char *temp, int flag) &#123;</span><br><span class="line">    name = new char[strlen(temp) + 1];</span><br><span class="line">    strcpy(name, temp);</span><br><span class="line">    age = flag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void change(Person &amp;someOne) &#123;</span><br><span class="line">    someOne.name = &quot;Robot&quot;;</span><br><span class="line">    someOne = Person(&quot;SomeOne&quot;, 18);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> </span><br><span class="line">    Person person(&quot;Hello&quot;, 20);</span><br><span class="line">    change(person);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的内存分布如图：<br><img data-src="https://s2.ax1x.com/2020/03/11/8EMsZd.png" alt="swift_struct_class_引用类型的三种传参"></p>
<p>我们分析一下引用类型下的三种传参，</p>
<ol>
<li>值传参，因为引用类型不支持值传参，所以我们使用copy，模拟了值传参。这也是<strong>深拷贝</strong>的实现方式。我们通过自定义copy来实现引用类型的值传参。</li>
<li>地址传参，和值类型的地址传参没有区别。</li>
<li>引用传参，和值类型的引用传参没有区别。</li>
</ol>
<p>我们发现，值类型的直接赋值，使用的是值传参。引用类型的直接赋值，使用的是地址传参。而在值类型下的三种传参分析中，我们分析到<strong>地址传参就是特殊的值传参</strong>。<br>所以我们可以得出结论，<strong>值类型和引用类型的直接赋值，都是值传参的形式</strong>。而引用传参，需要语言级别的实现，目前C++有实现，Java、Objective-C、Swift等语言中皆没有实现。</p>
<h4 id="花式传参总结"><a href="#花式传参总结" class="headerlink" title="花式传参总结"></a>花式传参总结</h4><p>值传参、地址传参、引用传参，是数据赋值过程中的不同表现形式。而地址传参，本质还是值传参。所以我们可以说只有两种传参方式，即值传参和引用传参。<br>而值传参和引用传参，和值类型与引用类型不是一一对应的关系，具体不同是下文说到的语义的不同，即：</p>
<ol>
<li>根据我们使用的场景，我们可以通过将值传参和引用传参作用于值类型对象上。</li>
<li>根据我们使用的场景，我们也可以通过将值传参和引用传参作用于引用类型对象上。</li>
<li>如果我们需要改变实参，则我们需要引用传参。(很多语言不支持)</li>
<li>如果我们不需要改变实参，则我们需要值传参。如果想进一步改变原对象的部分值，则需要地址传参通过指针来实现。</li>
</ol>
<h3 id="0X04-值语义和引用语义的联动性"><a href="#0X04-值语义和引用语义的联动性" class="headerlink" title="0X04 值语义和引用语义的联动性"></a>0X04 值语义和引用语义的联动性</h3><p>直观来说，值类型语法上是静态的，变量直接包含并操作数据。引用类型语法上是动态的，通过对象的引用操作数据。从值类型和引用类型的内存结构图可以分析出来。<br>所以，我们引申出<strong>值语义</strong>，即数据是静态的，也就是值传参的逻辑，是数据拷贝，是一份全新的数据。<br>我们也引申出<strong>引用语义</strong>，即数据是动态的，也就是引用传参的逻辑，数据可以通过别名操作，数据本身没有进行任何复制。<br>所以我们可以这样理解，值类型默认应该是值语义的，引用类型默认应该是引用语义的。<br>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 值变量v1与v2互相独立</span><br><span class="line">ValueType v1 = someValue;</span><br><span class="line">ValueType v2 = v1;</span><br><span class="line"></span><br><span class="line">// 引用变量r1与r2互相关联</span><br><span class="line">ReferenceType r1 = someObject;</span><br><span class="line">ReferenceType r2 = r1;</span><br></pre></td></tr></table></figure>
<p>上面v1和v2都是值类型ValueType的对象，其中v1和v2没有任何关联，默认的值传参。<br>上面r1和r2都是引用类型ReferenceType的对象，其中r2是r1的别名，操作r2和操作r1完全一样。</p>
<p>但是事与愿违，至少引用类型的默认引用传参，就是很多语言所不支持的。我们的Swift就没有办法实现引用类型的引用传参。即上面的r1和r2如果在Swift中定义，那么r2不是r1的别名，仅仅是r1存储的someObject地址的一份拷贝。</p>
<p>所以，严格按照引申出来的<strong>值语义</strong>和<strong>引用语义</strong>的定义，那么很多语言都没有引用语义了。这显然是片面的，因为我们的地址传参，也可以通过指针操作数据来实现动态性。<br>所以严格的定义如下：<br><strong>值语义的对象是独立的，</strong><br><strong>引用语义的对象却是允许共享的。</strong><br>理解下来，就是：<br>值传参具有值语义，因为值传参后行参实参两个对象完全独立。<br>地址传参和引用传参，具有引用语义，因为行参可以通过指针或者别名（实质还是指针，间接寻址方式）来操作实参对象。</p>
<p>我们在“花式传参”中说到有6种传参方式，因为值类型对应三种传参，引用类型也对应三种传参。<br>所以我们可以发现：<br><strong>值类型通过地址传参和引用传参，可以实现引用语义。</strong><br><strong>引用类型通过值传参，可以实现值语义。</strong><br><img data-src="https://s2.ax1x.com/2020/03/11/8EMBse.png" alt="swift_struct_class_值语义和引用语义"></p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的 ValueType具有引用语义(C++)</span><br><span class="line">ValueType v1 = someValue;</span><br><span class="line">ValueType&amp; v2 = v1;             // 方法1：通过引用让v2成为v1的别名</span><br><span class="line">ValueType* v3 = &amp;v1;            // 方法2：通过指针让v3指向v1</span><br><span class="line"> </span><br><span class="line">// 引用类型的ReferenceType具有值语义</span><br><span class="line">ReferenceType r1 = someObject;</span><br><span class="line">ReferenceType r2 = r1.copy();    // r1与r2是两个完全独立的对象</span><br></pre></td></tr></table></figure>
<p>而相应的语言如Objective-C就有很多语义层级的类型处理，将值类型处理成引用语义，将引用类型处理成值语义。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// int值类型具有引用语义</span><br><span class="line">int i1 = 8;</span><br><span class="line">int *i2 = &amp;i1;</span><br><span class="line">(*i2)++;</span><br><span class="line">NSLog(@&quot;i:%d,ii:%d&quot;, i1, *i2);// i1:9,i2:9</span><br><span class="line"> </span><br><span class="line">// NSString引用类型具有值语义</span><br><span class="line">NSString *s1 = @&quot;s1 value&quot;;</span><br><span class="line">NSString *s2 = s1;</span><br><span class="line">s2 = @&quot;s2 value&quot;;</span><br><span class="line">NSLog(@&quot;s1:%@,s2:%@&quot;, s1, s2);// s1:s1 value,s2:s2 value</span><br></pre></td></tr></table></figure>
<p>所以，<br>语法上的值类型可能是语义上的引用类型，<br>语法上的引用类型可能是语义上的值类型。</p>
<h3 id="0X05-值类型和引用类型的抽象层级差异"><a href="#0X05-值类型和引用类型的抽象层级差异" class="headerlink" title="0X05 值类型和引用类型的抽象层级差异"></a>0X05 值类型和引用类型的抽象层级差异</h3><p>在文章开头提到的值类型和引用类型的内存模型中，已经明确值类型是直接包含数据，而引用类型是通过内存地址间接操作数据。<br>从内存分布上，我们可以模糊的发现：</p>
<ol>
<li><strong>值类型，重在数据，是静态的。</strong>如果一个数据是通过值类型来展示，那么这个数据重在数据的价值。这个数据一定非常重要，而我们可以通过值变量直接获取。</li>
<li><strong>引用类型，重在如何使用，是动态的。</strong>如果一个数据是通过引用类型来展示，那么这个数据重在如何被使用。这个数据当然也重要，但是我们可以通过指针和引用(别名&#x2F;间接寻址)变相获取，而指针可以赋值给其他变量，最后可以通过各个变量来获取。</li>
</ol>
<p>我们可以创建各种面向对象的引用类型(class)，然后实现继承和多态，这是引用类型带来的益处。因为我们可以通过指针和引用轻松的实现多态特征。<br>而对于值类型(struct)，Swift文档里直接说明，struct不允许继承和重载。值类型在编译期间具体类型就已经确定，多态绑定也是不可能，因为其空间大小已经确定，没有空余空间容纳子类型。<br>所以从抽象层级上来观看，引用类型相比值类型，抽象层级更高。</p>
<p>因为值类型在编译期间空间大小和具体类型已经确定，所以值类型完全就是不依赖内存地址的，这也是为什么值变量直接包含值对象的原因，所以值类型是具有<strong>空间无关性</strong>的。而引用类型存储于堆中，必须通过指针进行访问，显然引用类型和空间是强关联的。<br>而且，值类型的数据在值对象生命周期内是固定的，体现了不可变性，具有<strong>时间无关性</strong>。即使通过地址传参和引用传参，我们可以改变值对象的数据，那也是在原来的存储空间中，用新数据覆盖旧数据，使用了旧数据的存储空间而已。引用类型的改变是一种自我更新，对象上发生状态迁移和属性改变。<br>因为值类型的时间无关性和空间无关性，所以值类型天然具有重数据，对象意识淡薄，更多的体现在属性而非实体。比如我们描述一个Person的struct，更多的体现在用age，sex等抽象属性来描述“20”“男”这样的具体数据（“20”、“男”本身是具体的，age、sex属性则是面向对象层级的抽象描述）。<br>而引用类型与值类型相比是对立面的抽象表达，更多的体现一个实体对象。比如我们描述一个Person的class，更多的体现在男人、女人、好人、坏人这样的实体对象。</p>
<p>总结来看，值类型是引用类型的基础，值类型在内存和速度的使用上，拥有更快的速度。引用类型在值类型之上进行了更多的抽象。<br>引用类型依靠间接性和抽象性，相比值类型拥有来更大的灵活性，小方面来说在赋值上通过地址传参和引用传参节省了时间损耗，大方面来说通过间接性和抽象性，直接成为实现多态的必要条件。<br>这也从侧面反映了class可以继承和多态，看起来繁荣昌盛，而struct则显得不起眼，为居一隅却撑起来整个面向对象大厦。</p>
<h3 id="0X06-struct和class联动内嵌下的认知"><a href="#0X06-struct和class联动内嵌下的认知" class="headerlink" title="0X06 struct和class联动内嵌下的认知"></a>0X06 struct和class联动内嵌下的认知</h3><p>单个分析值类型和引用类型还比较容易理解，如果值类型和引用类型相互嵌套，虽然并不是复杂的逻辑，但如果不画图理解一下，很容易脑回路阻塞。<br>下面通过示例代码和内存图清晰了解一下：</p>
<h4 id="值类型嵌套值类型"><a href="#值类型嵌套值类型" class="headerlink" title="值类型嵌套值类型"></a>值类型嵌套值类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://s2.ax1x.com/2020/03/11/8EM5LQ.png" alt="swift_struct_class_值类型引用类型互嵌1"></p>
<h4 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    // 引用类型</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = Dog(name: &quot;Wa&quot;)</span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20, dog: dog)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://s2.ax1x.com/2020/03/11/8EMRRf.png" alt="swift_struct_class_值类型引用类型互嵌2"></p>
<h4 id="引用类型嵌套值类型"><a href="#引用类型嵌套值类型" class="headerlink" title="引用类型嵌套值类型"></a>引用类型嵌套值类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var dog = Dog(name: &quot;Wa&quot;)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://s2.ax1x.com/2020/03/11/8EMhQS.png" alt="swift_struct_class_值类型引用类型互嵌3"></p>
<h4 id="引用类型嵌套引用类型"><a href="#引用类型嵌套引用类型" class="headerlink" title="引用类型嵌套引用类型"></a>引用类型嵌套引用类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    // 引用类型</span><br><span class="line">    init(name: String, age: UInt8, dog: Dog) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.dog = dog</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = Dog(name: &quot;Wa&quot;)</span><br><span class="line">var person = Person(name: &quot;Gongjiang&quot;, age: 20, dog: dog)</span><br><span class="line">person.name = &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://s2.ax1x.com/2020/03/11/8EMWz8.png" alt="swift_struct_class_值类型引用类型互嵌4"></p>
<h3 id="0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？"><a href="#0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？" class="headerlink" title="0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？"></a>0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？</h3><p>本身struct不是很特别，但是在目前很流行的语言（Objective-C、Java）均不支持自定义struct的前提下，Swift开始支持了。而且Swift本身如String、Int、Bool等均为struct。Swift把已经被很多开发人员忽视的值类型提到了非常高的高度，这就非常值的重视了。</p>
<ol>
<li>值对象本身是比引用对象安全的。通过指针可以直接操作数据，如果代码逻辑比较复杂，那么在一个不起眼的位置，很可能修改了一个共享的重要参数，非常有利于bug的滋生和增加bug排查复杂度。相比来说，值对象具有空间无关性，代码层面上可以有效的抵制指针带来的负面影响。所以值对象是更安全的。</li>
<li>struct没有引用计数，本身是自动线程安全的。</li>
<li>在上面<strong>值类型和引用类型的内存差异</strong>中，我们说到，值类型相比引用类型，有速度上的天然优势。</li>
<li>struct没有继承，相对来说更安全，而且struct可以实现协议，可以很好的实现面向协议编程。Swift是一门多范式编程的语言，其中对于面向协议编程尤其重视。</li>
</ol>
<h3 id="OX08-Swift下String的搅局误区"><a href="#OX08-Swift下String的搅局误区" class="headerlink" title="OX08 Swift下String的搅局误区"></a>OX08 Swift下String的搅局误区</h3><p>在讨论Swift的值类型中，多次提到String类型是值类型的。我相信很多朋友都疑惑，String作为值类型是如何实现的。<br>毕竟，下面的代码中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) &#123; (value) in</span><br><span class="line">    print(value)    // 0x0000000100145060</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.append(&quot;Hello...Hello&quot;) // 有1000个Hello</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) &#123; (value) in</span><br><span class="line">    print(value)    // 0x0000000100145060</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个可变变量str为值类型的字符串变量，按照内存图逻辑，在str拼接了1000个Hello后，再怎么说，str的空间存储也不够了。<br>如果str的内存地址变化了，那么就说明str不是值类型了（上面我们说过值类型的内存变化）。<br>如果str的内存地址没有变，那str再怎么也存储不了无限多个字符啊！<br>我们拿Int来做对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i: Int8 = 10</span><br><span class="line">i = 10000000    // Error</span><br></pre></td></tr></table></figure>
<p>这里如果对Int8值类型的变量赋值过大，首先编译就过不了了，超过Int8的存储空间了嘛。<br>值类型的空间大小，在编译时就已经确定，这是毋庸置疑的。<br>那String是如何做到的呢？<br>打印一下上面代码中的str大小，看看到底是多大：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    // 16</span><br><span class="line"></span><br><span class="line">str.append(&quot;Hello...Hello&quot;) // 有1000个Hello</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    // 16</span><br></pre></td></tr></table></figure>
<p>可以发现，str的内存大小，没有变化过…<br>这也说明了，String的确是值类型的，它真的可以存储非常非常多的字符。<br>我在查看了“<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWppb3Mv">M了个J<i class="fa fa-external-link-alt"></i></span>”大神的博客后，依然无解，因为他把答案公布在了两小时的汇编视频中，而我没有去看。<br>这里把大神的博客放下，希望有心人能去窥探一下。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWppb3MvcC8xMTc5OTEzNi5odG1s">https://www.cnblogs.com/mjios/p/11799136.html<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>朋友对我说，抽象是一名程序员核心的能力。很多时候，我越发觉得这句话说的对！</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="followme">
  <span>Follow me by other channels</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/one_gongjiang">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://t.me/gongjiang">
          <span class="icon">
            <i class="fab fa-telegram"></i>
          </span>

          <span class="label">Telegram</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="mailto:one.gongjiang@gmail.com">
          <span class="icon">
            <i class="fa fa-envelope"></i>
          </span>

          <span class="label">Email</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Swift/" rel="tag"># Swift</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/%E9%80%83%E7%A6%BB%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%92%8C%E8%8A%B1%E5%91%97/" rel="prev" title="逃离信用卡和花呗">
                  <i class="fa fa-chevron-left"></i> 逃离信用卡和花呗
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/%E6%88%91%E7%9A%84%202019%20%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" rel="next" title="我的 2019 年个人总结">
                  我的 2019 年个人总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">one.gongjiang艾特gmail.com 所有文章均为原创。我不介意任意形式的转载，但最好不要修改内容。因转载或者修改内容导致的任何问题，我均不负责。如果你真的担心版权，可邮联。</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.yigegongjiang.com/2019/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yigegongjiang","repo":"yigegongjiang_discuss","client_id":"65bebc0a049450012bda","client_secret":"06004e7143dc59f263a8d1bd1893dcf66d6bb7ee","admin_user":"yigegongjiang","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"403ba678b8d751648aa8cd4f8768fac8"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
