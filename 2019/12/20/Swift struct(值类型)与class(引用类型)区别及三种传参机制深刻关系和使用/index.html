<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">

<meta name="google-site-verification" content="hEkkdHoBZXdN-chbhMtLxz6orIp7_P0lfW61l88LlIw" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.yigegongjiang.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: true,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<script data-ad-client="ca-pub-6982021533088600" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta name="description" content="在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。 因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objec">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用">
<meta property="og:url" content="https://www.yigegongjiang.com/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="一个工匠">
<meta property="og:description" content="在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。 因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objec">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E8%AF%AD%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C1.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C2.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C3.png">
<meta property="og:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C4.png">
<meta property="article:published_time" content="2019-12-19T16:00:00.000Z">
<meta property="article:modified_time" content="2020-01-29T13:44:11.860Z">
<meta property="article:author" content="one.gongjiang@gmail.com">
<meta property="article:tag" content="Swift、sturct、class、值类型、引用类型、值传参、地址传参、引用传参、抽象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.yigegongjiang.com/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png">

<link rel="canonical" href="https://www.yigegongjiang.com/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用 | 一个工匠</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个工匠</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">跋山涉水，走心为匠。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.yigegongjiang.com/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="one.gongjiang@gmail.com">
      <meta itemprop="description" content="跋山涉水，走心为匠。IT,互联网,网络,开发,硬件,生活,移动互联网">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个工匠">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Swift struct(值类型)与class(引用类型)区别及三种传参机制深刻关系和使用
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-20T00:00:00+08:00">2019-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在Swift中，struct（值类型）和class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。<br>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。</p>
<p>因为struct和class表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objective-C里面的NSString，它是引用类型，但是我们却在使用它的值语义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *oldname &#x3D; @&quot;hello&quot;.mutableCopy;</span><br><span class="line">NSMutableString *newname &#x3D; oldname;</span><br><span class="line">newname &#x3D; @&quot;word&quot;.mutableCopy;</span><br><span class="line">NSLog(@&quot;\n oldName:%@ \n newName:%@&quot;, oldname, newname);</span><br><span class="line"> </span><br><span class="line">&gt; oldName:hello </span><br><span class="line">&gt; newName:word</span><br></pre></td></tr></table></figure>
<p>我们使用了引用类型的NSMutableString，但是newname并没有引用复制oldname，仅仅是指针地址复制了oldname。这样导致了newname并不是oldname的别名(alias)。<br>如果newname是oldname的别名，那么对newname的所有all操作，都会同步到oldname。<br>这里，newname如果改变了对象数据是可以同步到oldname，但是却不能改变oldname变量的值（oldname的存储值，即“hello”的指针地址）。<br>所以，这里的NSMutableString虽然是引用类型，却具有值语义。</p>
<p>因为编程语言概念上的模糊，下面首先介绍struct和值类型的关系。<br>然后重点说明值类型和引用类型的区别，这是重点，直接解释了struct和class的根本区别。<br>最后加一点小彩蛋，介绍Swift里面struct特性。</p>
<a id="more"></a>

<h3 id="0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？"><a href="#0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？" class="headerlink" title="0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？"></a>0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？</h3><p>好久好久之前，是没有class什么事的。那时候C语言活跃于各种应用场景，在上层抽象了汇编的实现，C语言可以用于嵌入式、服务器、驱动等。为什么没有class什么事情？class是类，是OOP（面向对象编程/对象导向编程）的专属。而C语言是过程式语言，没有对象概念，也就没有class什么事情。<br>那时候，都用结构体，也就是struct。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C语言版本</span><br><span class="line">&#x2F;&#x2F; 人员结构体，具有姓名和年龄</span><br><span class="line">struct Person &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那时候，这些数据都叫做<strong>值类型</strong>，而struct就是值类型的。值类型是<strong>变量直接包含值</strong>统称，其他的还有基础数据类型，如Int，long，char，bool，以及自定义struct（如上面的Person）。<br>后面大家就知道了，出现了C++/Java/C#等OOP语言，class开始活跃于千万家。更甚之，在某些语言上，值类型已经被淡化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objective-C版本 .h</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line">@property(nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以上为OC的版本，我们会这么描述它：我们创建了一个Person类。他具有名称属性和年龄属性。<br>而且，我们也确定，如果我们新建一个Person对象,如<code>Person *p = Person.new;</code>，那么这个对象一定存放在堆内存。那我们为什么不能把对象创建在栈内存呢？<br>我们可以知道，上面OC创建的是Class，对象存在于堆中。那我们可不可以把对象放在栈上？至少在Objective-C开发过程中，肯定不会想到这个，因为struct/结构体/值类型被淡化了。（Java也是一样，号称纯OOP语言）<br>其实我们可以创建栈上的数据的，如局部变量中的Int、long等，都是在栈上的。说一个少见的，CGRect、CGSize也是在栈上的。源码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Points. *&#x2F;</span><br><span class="line">struct</span><br><span class="line">CGPoint &#123;</span><br><span class="line">    CGFloat x;</span><br><span class="line">    CGFloat y;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGPoint CGPoint;</span><br><span class="line"></span><br><span class="line">&#x2F;* Sizes. *&#x2F;</span><br><span class="line"></span><br><span class="line">struct CGSize &#123;</span><br><span class="line">    CGFloat width;</span><br><span class="line">    CGFloat height;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGSize CGSize;</span><br><span class="line"></span><br><span class="line">&#x2F;* Rectangles. *&#x2F;</span><br><span class="line"></span><br><span class="line">struct CGRect &#123;</span><br><span class="line">    CGPoint origin;</span><br><span class="line">    CGSize size;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CG_BOXABLE CGRect CGRect;</span><br></pre></td></tr></table></figure>
<p>其实OC中使用的CGRect等，也就是struct值类型数据。只是我们很少顾及值类型，虽然一直用，但是感知不到他们的存在。<br>直到有一天，Swift也成了苹果开发的官方语言，引入了struct，一大堆开发人员开始迷惑，发生了什么事？我该怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的Person，一个是struct，一个是class。一个复制的时候是全部数据复制，一个复制的时候是指针复制。一个有可能存放在栈上，一个只能存放在堆上。<br>放心了很多，原来struct和Int、BOOL等是一样的。他们本身不可以改变，只能被复制。struct拥有和Int一样的外观。<br>等等，Swift的struct可以引入方法，可以实现构造器，甚至可以通过mutating来改变自己。俨然已经上升可以和class平起平坐了（其实没有高低之分）。这怎么和Int又不太一样了？struct到底是啥？</p>
<p>其实struct一直都没有消失。它一直在我们周边。仅仅是因为我们在个别面向对象语言的冲击下，淡化了值类型。<br>而现在，在Swift中，我们必须捡起来，因为值类型在Swift中不可或缺了。甚至Swift里面的Int,String等，都是通过struct直接实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A signed integer value type.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; On 32-bit platforms, &#96;Int&#96; is the same size as &#96;Int32&#96;, and</span><br><span class="line">&#x2F;&#x2F;&#x2F; on 64-bit platforms, &#96;Int&#96; is the same size as &#96;Int64&#96;.</span><br><span class="line">public struct Int : FixedWidthInteger, SignedInteger &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; A type that represents an integer literal.</span><br><span class="line">    public typealias IntegerLiteralType &#x3D; Int</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，C++一直存在值类型，而且C++里面的自定义的struct还可以继承和多态，完全面向对象化了。</p>
<h3 id="0X01-值类型和引用类型的内存差异"><a href="#0X01-值类型和引用类型的内存差异" class="headerlink" title="0X01 值类型和引用类型的内存差异"></a>0X01 值类型和引用类型的内存差异</h3><p>值类型和引用类型，从语法上还是毕竟容易理解的。如果牵涉到语义，就比较复杂，因为上面说到的，引用类型就牵涉到了值语义。<br>我们先从语法上来理解值类型和引用类型的内存差异。</p>
<h4 id="引用类型内存图"><a href="#引用类型内存图" class="headerlink" title="引用类型内存图"></a>引用类型内存图</h4><p>首先，class是引用类型，一定是存放在堆内存上的。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: UInt8?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person</span><br><span class="line">someOne.name &#x3D; &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">&gt; person.name:Robot</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></table></figure>
<p>那么我们定义一个Person对象时候的内存分布如下图：<br><img src="/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt=""><br>person这个引用变量，我们使用的时候，可能存储在栈中的（也可能在堆中，但不是重点）。但是其指向的对象，却一定是在堆中的。</p>
<blockquote>
<p>这里我们有两个名词认知不要弄混了，一个是person变量，一个是person对象。变量只是符号，编译的时候存储于符号表中的一个标记，对象才是我们使用的数据实体，变量用于找到对象。someOne也是同理。下文中的变量和对象都是同理，后面不再做强调。</p>
</blockquote>
<p>上面操作完成后，person和someOne的name都变成Robot了，这是合情合理的，我们都司空见惯了，不做多描述。</p>
<h4 id="值类型内存图"><a href="#值类型内存图" class="headerlink" title="值类型内存图"></a>值类型内存图</h4><p>下面看看值类型，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person</span><br><span class="line">someOne.name &#x3D; &quot;Robot&quot;</span><br><span class="line"></span><br><span class="line">&gt; person.name:Hello</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></table></figure>
<p>内存分布如下图：<br><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B.png" alt=""><br>我们可以发现，值类型相比引用类型，person和someOne这两个值变量，<strong>指向</strong>特征不那么明显了，更多的是复制。我们的someOne并没有指向person，而是把person的数据完全复制了一份成为自己的。<br>更重要的，person和someOne存储的，<strong>不再是对象的指针，而是真真实实的数据了</strong>。其实对象依旧还是对象，变量依旧是变量，如上面说的那样。但是，<strong>值变量，直接包含数据(值类型的定义)</strong>了，不再通过指针指向数据了。<br>当然，我们从图上看到的，值对象是在栈里面。当然值对象也会在堆里面，场景不一样，存储位置也会不一样。但是和引用对象不同的一点，<strong>值对象是可以存储在栈里面的</strong>。</p>
<blockquote>
<p>我们经常使用的Int等，其实很多时候都是存储在栈里面的。上面Person引用类，其实也有age属性，这个age属性就是值对象存储在堆上，因为person对象是在堆上的。后面说到struct和class联动内嵌的时候，会详细说明</p>
</blockquote>
<h4 id="值类型和引用类型内存比较"><a href="#值类型和引用类型内存比较" class="headerlink" title="值类型和引用类型内存比较"></a>值类型和引用类型内存比较</h4><p>显而易见，内存方式的不同，带来的优缺点也是迥异的。<br>最直接的，栈肯定是比堆快的。下面我们默认<strong>值对象存储在栈中，引用对象存储在堆中</strong>进行分析。<br><strong>一来</strong>，值类型通过值变量直接定位数据，而引用类型需要通过引用变量的指针间接获取，在寻址方面就会出现时间劣势。<br><strong>再者</strong>，栈通过CPU提供的指令寄存器操作数据，而堆通过操作系统支持。堆空间由程序员自行控制，包括垃圾回收等，CPU不会干预过多。<br><strong>其次</strong>，我们在栈上分配内存，是直接分配。而对于引用类型，只在栈上分配变量地址，对象需要另外分配堆内存空间。（可能会出现这种情况，需要100个对象，栈类型会在栈内存中直接分配完毕，而引用类型会在栈上一次性分配100个变量内存，然后在堆中需要进行100次对象内存分配。）<br><strong>而且</strong>，由于堆内存是空间不连续性的（操作系统分配堆内存池供开发使用，如果一个对象销毁了，就会产生内存碎片），不连续堆空间会违背局部性原理，会增加高速缓存错失的几率（命中不了）。堆空间的高速缓存指的是二级缓存，而栈是依据“LIFO”的存储机制，不会出现内存碎片，天然增加了一级缓存的命中率。<br><strong>特别</strong>，各种语言都会着重优化值类型，以达到更快的速度。毕竟栈处理速度的快慢，直接影响到程序的快慢。因为我们的代码运行根本依靠函数，而函数就是在栈中执行，如main函数和自定义函数。所以才会加入寄存器这样的快速单元，而堆里的数据，是可以通过异步来完成存储的。<br>因为值对象也是会存储在堆中，所以我们可以这样说：<strong>值类型有可能利用栈的优势，进一步提高程序的性能</strong>。</p>
<p>内存比较上，相比来说，值类型完胜引用类型。<br>引用类型相应的优点，<br>一来，发生在拷贝的过程中。值类型拷贝是完全拷贝，所有数据都会拷贝一遍，而引用类型，拷贝的仅仅是指针，从而提交效率。<br>二来，栈内存空间有有限的，相比堆内存空间，简直太小来，如著名的网站“Stack Overflow”的名字一样，动不动就会栈溢出。而堆内存，就是普通点的服务器，4G容量不是问题的，高级点的服务器都是几十几百G容量。<br>我们可以看出，栈和堆相比，强于速度，弱于空间。虽然速度完胜，但除了空间，还有其他方面，引用类型却又是完胜值类型的。从Java，Objective-C这些语言上不难看出，引用类型的确是完胜值类型的。下面我们一点点来分析他们之间的不同和场景应用。</p>
<h3 id="0X02-值类型和引用类型的相等性差异"><a href="#0X02-值类型和引用类型的相等性差异" class="headerlink" title="0X02 值类型和引用类型的相等性差异"></a>0X02 值类型和引用类型的相等性差异</h3><h4 id="值类型相等性比较"><a href="#值类型相等性比较" class="headerlink" title="值类型相等性比较"></a>值类型相等性比较</h4><p>我们回顾一些最基础的值类型Int的相等性比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1 &#x3D; 100</span><br><span class="line">var num2 &#x3D; 100</span><br><span class="line">assert(num1 &#x3D;&#x3D; num2)</span><br><span class="line">var num3 &#x3D; 200</span><br><span class="line">assert(num1 !&#x3D; num3)</span><br></pre></td></tr></table></figure>
<p>上面代码编译运行，断言是可以通过的。值类型的比较，特别简单，就是比较数据是否一样。<br>因为值类型，不管存储在哪里，不变的一点是，值变量直接包含值对象。我们自定义一个值类型来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person: Equatable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person</span><br><span class="line">someOne.name &#x3D; &quot;Hello&quot;</span><br><span class="line">&#x2F;&#x2F; someOne.name &#x3D; &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">assert(person &#x3D;&#x3D; someOne)</span><br><span class="line">&#x2F;&#x2F; assert(person !&#x3D; someOne)</span><br></pre></td></tr></table></figure>
<p>它们的内存图如下：<br><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7.png" alt=""><br>当两个值对象的name都是Hello的时候，两个值对象是相等的。如果someOne的name变成Robot，两个值对象就是不想等的。（如果我们把注释的代码打开，相应注释位置上一行代码删除，会发现两个断言都是可以通过的。）<br>值类型的相等性比较真的非常简单，就是匹配字节码是否一致。只要值对象的所有字节码是一致的，那两个值对象就是相等的。字节码从哪里来？Hello和Robot，计算机不认识的，他们都会变成对应的码值然后转化成二进制存储内存中。所以值类型相等性判断就是查看二进制是否一样。</p>
<h4 id="引用类型相等性比较"><a href="#引用类型相等性比较" class="headerlink" title="引用类型相等性比较"></a>引用类型相等性比较</h4><p>因为引用变量存储的是引用对象的内存地址。同样一个对象，可能有两个引用变量存储着其地址。<br>所以引用类型的比较，有两个方面，一个是比较存储的内存地址是否一致，另一个是比较内存地址对应的数据是否一致。<br>因为字符串在Swift里面是值类型的，我们用Objective-C里面的NSString来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;%@&quot;, @&quot;Hello&quot;];</span><br><span class="line">NSString *str2 &#x3D; @&quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">assert(str1 &#x3D;&#x3D; str2);   &#x2F;&#x2F; ERROR</span><br><span class="line">assert([str1 isEqualToString:str2]); &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>
<p>相应的内存图如下：<br><img src="/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7.png" alt=""><br>因为Objective-C对于字符串的生成比较考究（Objective-C里面，字符串根据创建的形式不同和存储中英文的不同，有常量区、栈区、堆区不同表现形式），我们用上面方式建立两个不同地址的Hello字符串。其中比较相等性，一个是通过<strong>==</strong>，一个是通过<strong>equal</strong>。<br>引用类型的相等性比较，直接通过值类型的==比较的化，比较的是内存地址，显然str1和str2，他们的内存地址不可能一样，所以他们并不相等。<br>而通过equal来比较，就变成了上面的值类型的字节码比较，Hello的二进制存储都是一样的，他们就相等了。</p>
<h3 id="0X03-值类型和引用类型在花式传参过程中的异同"><a href="#0X03-值类型和引用类型在花式传参过程中的异同" class="headerlink" title="0X03 值类型和引用类型在花式传参过程中的异同"></a>0X03 值类型和引用类型在花式传参过程中的异同</h3><blockquote>
<p>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和struct、class的应用场景。</p>
</blockquote>
<p>为什么三种传参方式对struct和class的理解如此重要？其实他们本不重要，只是附带品。但是因为很多很多人对他们认知是错误的，所以才变得重要起来。<br>毕竟，错误的理论，总不能推导出来正确的知识。<br>首先，我们需要确定一个知识点，<strong>值传参</strong>、<strong>引用传参</strong>、<strong>地址传参</strong>和<strong>值类型</strong>、<strong>引用类型</strong>相比，虽然也有<strong>值</strong>和<strong>引用</strong>的区分，但他们不一一对应的关系，即不是值类型对应值传参。<br>值类型和引用类型是数据存在的方式，三种传参方式，是数据传递的方式。他们是对数据两个层面的操作控制。<br>所以，我们总共有6种情况需要分析：值类型下的值传参、引用传参、地址传参，引用类型下的值传参、引用传参、地址传参。<br>说明：因为引用传参很多语言默认都没有实现，如Java、Objective-C、Swift等等,所以需要通过C++模拟。</p>
<h4 id="值类型下的值传参、引用传参、地址传参"><a href="#值类型下的值传参、引用传参、地址传参" class="headerlink" title="值类型下的值传参、引用传参、地址传参"></a>值类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 值类型的值传参</span><br><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person: Equatable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person</span><br><span class="line">someOne.name &#x3D; &quot;Robot&quot;</span><br><span class="line">someOne &#x3D; Person(name: &quot;SomeOne&quot;, age: 18)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 值类型的地址传参</span><br><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">func change(someOne: inout Person) &#123;</span><br><span class="line">    someOne.name &#x3D; &quot;Robot&quot;</span><br><span class="line">    someOne &#x3D; Person(name: &quot;SomeOne&quot;, age: 18)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">change(someOne: &amp;person)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 值类型的引用传参</span><br><span class="line">&#x2F;&#x2F; C++ 版本</span><br><span class="line">void change(int &amp; param2)&#123;</span><br><span class="line">    param2++;</span><br><span class="line">    param2 &#x3D; 100;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int param1 &#x3D; 20;</span><br><span class="line">change(param1);</span><br></pre></td></tr></table></figure>
<p>上面的内存分布如图：<br><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82.png" alt=""></p>
<p>我们分析一下值类型下的三种传参，</p>
<ol>
<li>值传参，就是行参对象原封不动的获取了实参对象的<strong>数据拷贝</strong>。两个对象之间不再有任何关联，对行参对象的内部修改(someOne.name = “Robot”)和自身修改(someOne = Person(name: “SomeOne”, age: 18))，都不会更改另一个对象的任何数据。如上图所示，person对象没有任何修改。</li>
<li>地址传参，就是行参对象原封不动的获取了实参对象的<strong>地址拷贝</strong>。所以行参实际存储的是实参的内存地址拷贝。那么通过内存地址对数据的内部修改(someOne.name = “Robot”)都会影响到原对象，毕竟对象只有一个。但是行参自身修改(someOne = Person(name: “SomeOne”, age: 18))，却不会影响到原对象，因为行参是实参的地址拷贝，自身数据的改变就是改变了拷贝的那份内存地址，不会影响到实参。<strong>所以地址传参，本质还是值传参，因为拷贝了实参的内存地址（而非整个对象数据）</strong>。而通过内存地址修改原数据，这是一种途径，和传参无关，因为内存地址本身就是用来获取和修改数据的。</li>
<li>引用传参，分析起来其实最简单的。那就是，行参仅仅是实参的一个别名(alias)。行参存储的依旧是实参的内存地址拷贝，但是对行参所有的操作，都会通过<strong>间接寻址</strong>的方式直接操作实参。注意，是所有操作，因为行参仅仅是实参的别名。所以我们看到，引用传参里面，行参不仅可以修改原对象数据，还可以更换原对象。(这个更换原对象，有两种方式，上图中是其中一种，即在原对象内部修改数据，没有创建新对象。还有一种方式是创建一个全新的对象，然后实参指向新对象，是以新换旧的思想。但是原理都不变，都是行参操作实参直接改变数据。)</li>
</ol>
<p>通过上面值类型的三种传参，大家可能已经发现，在Objective-C、Java、Swift里面进行值类型的实参行参赋值的时候，其实<strong>都只是值传参和地址传参，并没有引用传参</strong>。只有个别语言如C++里面才支持引用传参。<br>上面说明的是值类型，那么引用类型的三种传参是否会有一些不同呢？</p>
<h4 id="引用类型下的值传参、引用传参、地址传参"><a href="#引用类型下的值传参、引用传参、地址传参" class="headerlink" title="引用类型下的值传参、引用传参、地址传参"></a>引用类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用类型的值传参</span><br><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; Person &#123;</span><br><span class="line">        return Person(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person.copy();</span><br><span class="line">person.name &#x3D; &quot;Robot&quot;</span><br><span class="line">someOne.name &#x3D; &quot;SomeOne&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用类型下的地址传参</span><br><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br><span class="line"> </span><br><span class="line">var someOne &#x3D; person;</span><br><span class="line">person.name &#x3D; &quot;Robot&quot;</span><br><span class="line"> </span><br><span class="line">someOne &#x3D; Person(name: &quot;SomeOne&quot;, age: 18)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用类型下的引用传参</span><br><span class="line">&#x2F;&#x2F; C++ 版本</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    Person(char *temp, int flag);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Person::Person(char *temp, int flag) &#123;</span><br><span class="line">    name &#x3D; new char[strlen(temp) + 1];</span><br><span class="line">    strcpy(name, temp);</span><br><span class="line">    age &#x3D; flag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void change(Person &amp;someOne) &#123;</span><br><span class="line">    someOne.name &#x3D; &quot;Robot&quot;;</span><br><span class="line">    someOne &#x3D; Person(&quot;SomeOne&quot;, 18);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> </span><br><span class="line">    Person person(&quot;Hello&quot;, 20);</span><br><span class="line">    change(person);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的内存分布如图：<br><img src="/images/swift_struct_class_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82.png" alt=""></p>
<p>我们分析一下引用类型下的三种传参，</p>
<ol>
<li>值传参，因为引用类型不支持值传参，所以我们使用copy，模拟了值传参。这也是<strong>深拷贝</strong>的实现方式。我们通过自定义copy来实现引用类型的值传参。</li>
<li>地址传参，和值类型的地址传参没有区别。</li>
<li>引用传参，和值类型的引用传参没有区别。</li>
</ol>
<p>我们发现，值类型的直接赋值，使用的是值传参。引用类型的直接赋值，使用的是地址传参。而在值类型下的三种传参分析中，我们分析到<strong>地址传参就是特殊的值传参</strong>。<br>所以我们可以得出结论，<strong>值类型和引用类型的直接赋值，都是值传参的形式</strong>。而引用传参，需要语言级别的实现，目前C++有实现，Java、Objective-C、Swift等语言中皆没有实现。</p>
<h4 id="花式传参总结"><a href="#花式传参总结" class="headerlink" title="花式传参总结"></a>花式传参总结</h4><p>值传参、地址传参、引用传参，是数据赋值过程中的不同表现形式。而地址传参，本质还是值传参。所以我们可以说只有两种传参方式，即值传参和引用传参。<br>而值传参和引用传参，和值类型与引用类型不是一一对应的关系，具体不同是下文说到的语义的不同，即：</p>
<ol>
<li>根据我们使用的场景，我们可以通过将值传参和引用传参作用于值类型对象上。</li>
<li>根据我们使用的场景，我们也可以通过将值传参和引用传参作用于引用类型对象上。</li>
<li>如果我们需要改变实参，则我们需要引用传参。(很多语言不支持)</li>
<li>如果我们不需要改变实参，则我们需要值传参。如果想进一步改变原对象的部分值，则需要地址传参通过指针来实现。</li>
</ol>
<h3 id="0X04-值语义和引用语义的联动性"><a href="#0X04-值语义和引用语义的联动性" class="headerlink" title="0X04 值语义和引用语义的联动性"></a>0X04 值语义和引用语义的联动性</h3><p>直观来说，值类型语法上是静态的，变量直接包含并操作数据。引用类型语法上是动态的，通过对象的引用操作数据。从值类型和引用类型的内存结构图可以分析出来。<br>所以，我们引申出<strong>值语义</strong>，即数据是静态的，也就是值传参的逻辑，是数据拷贝，是一份全新的数据。<br>我们也引申出<strong>引用语义</strong>，即数据是动态的，也就是引用传参的逻辑，数据可以通过别名操作，数据本身没有进行任何复制。<br>所以我们可以这样理解，值类型默认应该是值语义的，引用类型默认应该是引用语义的。<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 值变量v1与v2互相独立</span><br><span class="line">ValueType v1 &#x3D; someValue;</span><br><span class="line">ValueType v2 &#x3D; v1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引用变量r1与r2互相关联</span><br><span class="line">ReferenceType r1 &#x3D; someObject;</span><br><span class="line">ReferenceType r2 &#x3D; r1;</span><br></pre></td></tr></table></figure>
<p>上面v1和v2都是值类型ValueType的对象，其中v1和v2没有任何关联，默认的值传参。<br>上面r1和r2都是引用类型ReferenceType的对象，其中r2是r1的别名，操作r2和操作r1完全一样。</p>
<p>但是事与愿违，至少引用类型的默认引用传参，就是很多语言所不支持的。我们的Swift就没有办法实现引用类型的引用传参。即上面的r1和r2如果在Swift中定义，那么r2不是r1的别名，仅仅是r1存储的someObject地址的一份拷贝。</p>
<p>所以，严格按照引申出来的<strong>值语义</strong>和<strong>引用语义</strong>的定义，那么很多语言都没有引用语义了。这显然是片面的，因为我们的地址传参，也可以通过指针操作数据来实现动态性。<br>所以严格的定义如下：<br><strong>值语义的对象是独立的，</strong><br><strong>引用语义的对象却是允许共享的。</strong><br>理解下来，就是：<br>值传参具有值语义，因为值传参后行参实参两个对象完全独立。<br>地址传参和引用传参，具有引用语义，因为行参可以通过指针或者别名（实质还是指针，间接寻址方式）来操作实参对象。</p>
<p>我们在“花式传参”中说到有6种传参方式，因为值类型对应三种传参，引用类型也对应三种传参。<br>所以我们可以发现：<br><strong>值类型通过地址传参和引用传参，可以实现引用语义。</strong><br><strong>引用类型通过值传参，可以实现值语义。</strong><br><img src="/images/swift_struct_class_%E5%80%BC%E8%AF%AD%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89.png" alt=""></p>
<p>代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 值类型的 ValueType具有引用语义(C++)</span><br><span class="line">ValueType v1 &#x3D; someValue;</span><br><span class="line">ValueType&amp; v2 &#x3D; v1;             &#x2F;&#x2F; 方法1：通过引用让v2成为v1的别名</span><br><span class="line">ValueType* v3 &#x3D; &amp;v1;            &#x2F;&#x2F; 方法2：通过指针让v3指向v1</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 引用类型的ReferenceType具有值语义</span><br><span class="line">ReferenceType r1 &#x3D; someObject;</span><br><span class="line">ReferenceType r2 &#x3D; r1.copy();    &#x2F;&#x2F; r1与r2是两个完全独立的对象</span><br></pre></td></tr></table></figure>
<p>而相应的语言如Objective-C就有很多语义层级的类型处理，将值类型处理成引用语义，将引用类型处理成值语义。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; int值类型具有引用语义</span><br><span class="line">int i1 &#x3D; 8;</span><br><span class="line">int *i2 &#x3D; &amp;i1;</span><br><span class="line">(*i2)++;</span><br><span class="line">NSLog(@&quot;i:%d,ii:%d&quot;, i1, *i2);&#x2F;&#x2F; i1:9,i2:9</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; NSString引用类型具有值语义</span><br><span class="line">NSString *s1 &#x3D; @&quot;s1 value&quot;;</span><br><span class="line">NSString *s2 &#x3D; s1;</span><br><span class="line">s2 &#x3D; @&quot;s2 value&quot;;</span><br><span class="line">NSLog(@&quot;s1:%@,s2:%@&quot;, s1, s2);&#x2F;&#x2F; s1:s1 value,s2:s2 value</span><br></pre></td></tr></table></figure>
<p>所以，<br>语法上的值类型可能是语义上的引用类型，<br>语法上的引用类型可能是语义上的值类型。</p>
<h3 id="0X05-值类型和引用类型的抽象层级差异"><a href="#0X05-值类型和引用类型的抽象层级差异" class="headerlink" title="0X05 值类型和引用类型的抽象层级差异"></a>0X05 值类型和引用类型的抽象层级差异</h3><p>在文章开头提到的值类型和引用类型的内存模型中，已经明确值类型是直接包含数据，而引用类型是通过内存地址间接操作数据。<br>从内存分布上，我们可以模糊的发现：</p>
<ol>
<li><strong>值类型，重在数据，是静态的。</strong>如果一个数据是通过值类型来展示，那么这个数据重在数据的价值。这个数据一定非常重要，而我们可以通过值变量直接获取。</li>
<li><strong>引用类型，重在如何使用，是动态的。</strong>如果一个数据是通过引用类型来展示，那么这个数据重在如何被使用。这个数据当然也重要，但是我们可以通过指针和引用(别名/间接寻址)变相获取，而指针可以赋值给其他变量，最后可以通过各个变量来获取。</li>
</ol>
<p>我们可以创建各种面向对象的引用类型(class)，然后实现继承和多态，这是引用类型带来的益处。因为我们可以通过指针和引用轻松的实现多态特征。<br>而对于值类型(struct)，Swift文档里直接说明，struct不允许继承和重载。值类型在编译期间具体类型就已经确定，多态绑定也是不可能，因为其空间大小已经确定，没有空余空间容纳子类型。<br>所以从抽象层级上来观看，引用类型相比值类型，抽象层级更高。</p>
<p>因为值类型在编译期间空间大小和具体类型已经确定，所以值类型完全就是不依赖内存地址的，这也是为什么值变量直接包含值对象的原因，所以值类型是具有<strong>空间无关性</strong>的。而引用类型存储于堆中，必须通过指针进行访问，显然引用类型和空间是强关联的。<br>而且，值类型的数据在值对象生命周期内是固定的，体现了不可变性，具有<strong>时间无关性</strong>。即使通过地址传参和引用传参，我们可以改变值对象的数据，那也是在原来的存储空间中，用新数据覆盖旧数据，使用了旧数据的存储空间而已。引用类型的改变是一种自我更新，对象上发生状态迁移和属性改变。<br>因为值类型的时间无关性和空间无关性，所以值类型天然具有重数据，对象意识淡薄，更多的体现在属性而非实体。比如我们描述一个Person的struct，更多的体现在用age，sex等抽象属性来描述“20”“男”这样的具体数据（“20”、“男”本身是具体的，age、sex属性则是面向对象层级的抽象描述）。<br>而引用类型与值类型相比是对立面的抽象表达，更多的体现一个实体对象。比如我们描述一个Person的class，更多的体现在男人、女人、好人、坏人这样的实体对象。</p>
<p>总结来看，值类型是引用类型的基础，值类型在内存和速度的使用上，拥有更快的速度。引用类型在值类型之上进行了更多的抽象。<br>引用类型依靠间接性和抽象性，相比值类型拥有来更大的灵活性，小方面来说在赋值上通过地址传参和引用传参节省了时间损耗，大方面来说通过间接性和抽象性，直接成为实现多态的必要条件。<br>这也从侧面反映了class可以继承和多态，看起来繁荣昌盛，而struct则显得不起眼，为居一隅却撑起来整个面向对象大厦。</p>
<h3 id="0X06-struct和class联动内嵌下的认知"><a href="#0X06-struct和class联动内嵌下的认知" class="headerlink" title="0X06 struct和class联动内嵌下的认知"></a>0X06 struct和class联动内嵌下的认知</h3><p>单个分析值类型和引用类型还比较容易理解，如果值类型和引用类型相互嵌套，虽然并不是复杂的逻辑，但如果不画图理解一下，很容易脑回路阻塞。<br>下面通过示例代码和内存图清晰了解一下：</p>
<h4 id="值类型嵌套值类型"><a href="#值类型嵌套值类型" class="headerlink" title="值类型嵌套值类型"></a>值类型嵌套值类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C1.png" alt=""></p>
<h4 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Swift struct版本</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    &#x2F;&#x2F; 引用类型</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog &#x3D; Dog(name: &quot;Wa&quot;)</span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20, dog: dog)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C2.png" alt=""></p>
<h4 id="引用类型嵌套值类型"><a href="#引用类型嵌套值类型" class="headerlink" title="引用类型嵌套值类型"></a>引用类型嵌套值类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var dog &#x3D; Dog(name: &quot;Wa&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C3.png" alt=""></p>
<h4 id="引用类型嵌套引用类型"><a href="#引用类型嵌套引用类型" class="headerlink" title="引用类型嵌套引用类型"></a>引用类型嵌套引用类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Dog &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Swift class版本</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    &#x2F;&#x2F; 引用类型</span><br><span class="line">    init(name: String, age: UInt8, dog: Dog) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.dog &#x3D; dog</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog &#x3D; Dog(name: &quot;Wa&quot;)</span><br><span class="line">var person &#x3D; Person(name: &quot;Gongjiang&quot;, age: 20, dog: dog)</span><br><span class="line">person.name &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swift_struct_class_%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%B5%8C4.png" alt=""></p>
<h3 id="0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？"><a href="#0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？" class="headerlink" title="0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？"></a>0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？</h3><p>本身struct不是很特别，但是在目前很流行的语言（Objective-C、Java）均不支持自定义struct的前提下，Swift开始支持了。而且Swift本身如String、Int、Bool等均为struct。Swift把已经被很多开发人员忽视的值类型提到了非常高的高度，这就非常值的重视了。</p>
<ol>
<li>值对象本身是比引用对象安全的。通过指针可以直接操作数据，如果代码逻辑比较复杂，那么在一个不起眼的位置，很可能修改了一个共享的重要参数，非常有利于bug的滋生和增加bug排查复杂度。相比来说，值对象具有空间无关性，代码层面上可以有效的抵制指针带来的负面影响。所以值对象是更安全的。</li>
<li>struct没有引用计数，本身是自动线程安全的。</li>
<li>在上面<strong>值类型和引用类型的内存差异</strong>中，我们说到，值类型相比引用类型，有速度上的天然优势。</li>
<li>struct没有继承，相对来说更安全，而且struct可以实现协议，可以很好的实现面向协议编程。Swift是一门多范式编程的语言，其中对于面向协议编程尤其重视。</li>
</ol>
<h3 id="OX08-Swift下String的搅局误区"><a href="#OX08-Swift下String的搅局误区" class="headerlink" title="OX08 Swift下String的搅局误区"></a>OX08 Swift下String的搅局误区</h3><p>在讨论Swift的值类型中，多次提到String类型是值类型的。我相信很多朋友都疑惑，String作为值类型是如何实现的。<br>毕竟，下面的代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) &#123; (value) in</span><br><span class="line">    print(value)    &#x2F;&#x2F; 0x0000000100145060</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.append(&quot;Hello...Hello&quot;) &#x2F;&#x2F; 有1000个Hello</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) &#123; (value) in</span><br><span class="line">    print(value)    &#x2F;&#x2F; 0x0000000100145060</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个可变变量str为值类型的字符串变量，按照内存图逻辑，在str拼接了1000个Hello后，再怎么说，str的空间存储也不够了。<br>如果str的内存地址变化了，那么就说明str不是值类型了（上面我们说过值类型的内存变化）。<br>如果str的内存地址没有变，那str再怎么也存储不了无限多个字符啊！<br>我们拿Int来做对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i: Int8 &#x3D; 10</span><br><span class="line">i &#x3D; 10000000    &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>
<p>这里如果对Int8值类型的变量赋值过大，首先编译就过不了了，超过Int8的存储空间了嘛。<br>值类型的空间大小，在编译时就已经确定，这是毋庸置疑的。<br>那String是如何做到的呢？<br>打印一下上面代码中的str大小，看看到底是多大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    &#x2F;&#x2F; 16</span><br><span class="line"></span><br><span class="line">str.append(&quot;Hello...Hello&quot;) &#x2F;&#x2F; 有1000个Hello</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    &#x2F;&#x2F; 16</span><br></pre></td></tr></table></figure>
<p>可以发现，str的内存大小，没有变化过…<br>这也说明了，String的确是值类型的，它真的可以存储非常非常多的字符。<br>我在查看了“<a href="https://www.cnblogs.com/mjios/" target="_blank" rel="noopener">M了个J</a>”大神的博客后，依然无解，因为他把答案公布在了两小时的汇编视频中，而我没有去看。<br>这里把大神的博客放下，希望有心人能去窥探一下。<br><a href="https://www.cnblogs.com/mjios/p/11799136.html" target="_blank" rel="noopener">https://www.cnblogs.com/mjios/p/11799136.html</a></p>
<hr>
<p>朋友对我说，抽象是一名程序员核心的能力。很多时候，我越发觉得这句话说的对！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Swift/" rel="tag"># Swift</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/09/%E9%80%83%E7%A6%BB%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%92%8C%E8%8A%B1%E5%91%97/" rel="prev" title="逃离信用卡和花呗">
      <i class="fa fa-chevron-left"></i> 逃离信用卡和花呗
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/07/%E6%88%91%E7%9A%84%202019%20%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" rel="next" title="我的 2019 年个人总结">
      我的 2019 年个人总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？"><span class="nav-number">1.</span> <span class="nav-text">0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X01-值类型和引用类型的内存差异"><span class="nav-number">2.</span> <span class="nav-text">0X01 值类型和引用类型的内存差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型内存图"><span class="nav-number">2.1.</span> <span class="nav-text">引用类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型内存图"><span class="nav-number">2.2.</span> <span class="nav-text">值类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型和引用类型内存比较"><span class="nav-number">2.3.</span> <span class="nav-text">值类型和引用类型内存比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X02-值类型和引用类型的相等性差异"><span class="nav-number">3.</span> <span class="nav-text">0X02 值类型和引用类型的相等性差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型相等性比较"><span class="nav-number">3.1.</span> <span class="nav-text">值类型相等性比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型相等性比较"><span class="nav-number">3.2.</span> <span class="nav-text">引用类型相等性比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X03-值类型和引用类型在花式传参过程中的异同"><span class="nav-number">4.</span> <span class="nav-text">0X03 值类型和引用类型在花式传参过程中的异同</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型下的值传参、引用传参、地址传参"><span class="nav-number">4.1.</span> <span class="nav-text">值类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型下的值传参、引用传参、地址传参"><span class="nav-number">4.2.</span> <span class="nav-text">引用类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#花式传参总结"><span class="nav-number">4.3.</span> <span class="nav-text">花式传参总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X04-值语义和引用语义的联动性"><span class="nav-number">5.</span> <span class="nav-text">0X04 值语义和引用语义的联动性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X05-值类型和引用类型的抽象层级差异"><span class="nav-number">6.</span> <span class="nav-text">0X05 值类型和引用类型的抽象层级差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X06-struct和class联动内嵌下的认知"><span class="nav-number">7.</span> <span class="nav-text">0X06 struct和class联动内嵌下的认知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型嵌套值类型"><span class="nav-number">7.1.</span> <span class="nav-text">值类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型嵌套引用类型"><span class="nav-number">7.2.</span> <span class="nav-text">值类型嵌套引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型嵌套值类型"><span class="nav-number">7.3.</span> <span class="nav-text">引用类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用类型嵌套引用类型"><span class="nav-number">7.4.</span> <span class="nav-text">引用类型嵌套引用类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？"><span class="nav-number">8.</span> <span class="nav-text">0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OX08-Swift下String的搅局误区"><span class="nav-number">9.</span> <span class="nav-text">OX08 Swift下String的搅局误区</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">one.gongjiang@gmail.com</p>
  <div class="site-description" itemprop="description">跋山涉水，走心为匠。IT,互联网,网络,开发,硬件,生活,移动互联网</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">one.gongjiang@gmail.com</span>
</div>
  <div class="powered-by">
    跋山涉水，走心为匠。 By Hexo.
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://www.yigegongjiang.com/2019/12/20/Swift%20struct(%E5%80%BC%E7%B1%BB%E5%9E%8B)%E4%B8%8Eclass(%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%88%BB%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: true,
      notify: true,
      appId: 'gzcoXMhRjVA5qlkjOWugEMrG-MdYXbMMI',
      appKey: 'zHkhf61tDwyPJtTRCnzOLiWn',
      placeholder: "跋山涉水，走心为匠。",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
