<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.yigegongjiang.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":true,"sidebar":{"position":"left","width":140,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"text":"Light Mode (Better for light mode to discuss, base github, cannot commen can email me)","order":-2},"utterances":{"text":"Dark Mode","order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在 Swift 中，struct（值类型）和 class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和 struct、class 的应用场景。 因为 struct 和 class 表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift struct (值类型) 与 class (引用类型) 区别及三种传参机制深刻关系和使用">
<meta property="og:url" content="https://www.yigegongjiang.com/2019/SwiftStruct/index.html">
<meta property="og:site_name" content="一个工匠">
<meta property="og:description" content="在 Swift 中，struct（值类型）和 class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和 struct、class 的应用场景。 因为 struct 和 class 表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061808341.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061809607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061810033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061811891.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061811789.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061812422.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061813761.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061814818.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061814319.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061815244.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061815976.png">
<meta property="article:published_time" content="2019-12-19T16:00:00.000Z">
<meta property="article:author" content="海驴">
<meta property="article:tag" content="计算机原理">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061808341.png">


<link rel="canonical" href="https://www.yigegongjiang.com/2019/SwiftStruct/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.yigegongjiang.com/2019/SwiftStruct/","path":"2019/SwiftStruct/","title":"Swift struct (值类型) 与 class (引用类型) 区别及三种传参机制深刻关系和使用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Swift struct (值类型) 与 class (引用类型) 区别及三种传参机制深刻关系和使用 | 一个工匠</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8CTEWJ02QX"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-8CTEWJ02QX","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="一个工匠" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="一个工匠" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">一个工匠</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags<span class="badge">14</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives<span class="badge">104</span></a></li><li class="menu-item menu-item-日本香烟"><a href="/cigarette/" rel="section">日本香烟</a></li><li class="menu-item menu-item-日本指北"><a href="/japan/" rel="section">日本指北</a></li><li class="menu-item menu-item-时间舟"><a href="/categories/%E6%97%B6%E9%97%B4%E8%88%9F/" rel="section">时间舟</a></li><li class="menu-item menu-item-source"><a href="/openSource" rel="section">Source</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section">About</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section">RSS</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0X00-struct%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A5%BD%E5%83%8F%E5%9C%A8%E5%93%AA%E9%87%8C%E8%A7%81%E8%BF%87%EF%BC%81struct%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">0X00 struct 是什么？好像在哪里见过！struct 和值类型是什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X01-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B7%AE%E5%BC%82"><span class="nav-number">2.</span> <span class="nav-text">0X01 值类型和引用类型的内存差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text">引用类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">值类型内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.</span> <span class="nav-text">值类型和引用类型内存比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X02-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E5%B7%AE%E5%BC%82"><span class="nav-number">3.</span> <span class="nav-text">0X02 值类型和引用类型的相等性差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.</span> <span class="nav-text">值类型相等性比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83"><span class="nav-number">3.2.</span> <span class="nav-text">引用类型相等性比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X03-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E8%8A%B1%E5%BC%8F%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">4.</span> <span class="nav-text">0X03 值类型和引用类型在花式传参过程中的异同</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E5%8F%82%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82"><span class="nav-number">4.1.</span> <span class="nav-text">值类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E5%8F%82%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82"><span class="nav-number">4.2.</span> <span class="nav-text">引用类型下的值传参、引用传参、地址传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%B1%E5%BC%8F%E4%BC%A0%E5%8F%82%E6%80%BB%E7%BB%93"><span class="nav-number">4.3.</span> <span class="nav-text">花式传参总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X04-%E5%80%BC%E8%AF%AD%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E8%81%94%E5%8A%A8%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">0X04 值语义和引用语义的联动性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X05-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E7%BA%A7%E5%B7%AE%E5%BC%82"><span class="nav-number">6.</span> <span class="nav-text">0X05 值类型和引用类型的抽象层级差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X06-struct%E5%92%8Cclass%E8%81%94%E5%8A%A8%E5%86%85%E5%B5%8C%E4%B8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5"><span class="nav-number">7.</span> <span class="nav-text">0X06 struct 和 class 联动内嵌下的认知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">值类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">值类型嵌套引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">引用类型嵌套值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.4.</span> <span class="nav-text">引用类型嵌套引用类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X07-Swift%E4%B8%AD%E7%9A%84struct%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E7%89%B9%E5%88%AB%EF%BC%9Fstruct%E8%83%BD%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E8%AE%A4%E7%9F%A5%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">0X07 Swift 中的 struct 为什么很特别？struct 能给我们带来哪些认知？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OX08-Swift%E4%B8%8BString%E7%9A%84%E6%90%85%E5%B1%80%E8%AF%AF%E5%8C%BA"><span class="nav-number">9.</span> <span class="nav-text">OX08 Swift 下 String 的搅局误区</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="海驴"
      src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202309220309178.webp">
  <p class="site-author-name" itemprop="name">海驴</p>
  <div class="site-description" itemprop="description">时间，真的不多了。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9oYWlfbHZf" title="https:&#x2F;&#x2F;twitter.com&#x2F;hai_lv_">X(Twitter)</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.yigegongjiang.com/2019/SwiftStruct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202309220309178.webp">
      <meta itemprop="name" content="海驴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个工匠">
      <meta itemprop="description" content="时间，真的不多了。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Swift struct (值类型) 与 class (引用类型) 区别及三种传参机制深刻关系和使用 | 一个工匠">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift struct (值类型) 与 class (引用类型) 区别及三种传参机制深刻关系和使用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-20T00:00:00+08:00">2019-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>在 Swift 中，struct（值类型）和 class（引用类型）的区别，不仅仅在于对象复制时候表现出来的差异，也不仅仅是构造器和继承的异同，本质上却是数据抽象层级的高低。<br>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和 struct、class 的应用场景。</p>
<p>因为 struct 和 class 表现出来的是语法层面的差异，而项目使用中体现的是语义层级的差异。比如，Objective-C 里面的 NSString，它是引用类型，但是我们却在使用它的值语义。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *oldname = @"hello".mutableCopy;</span><br><span class="line">NSMutableString *newname = oldname;</span><br><span class="line">newname = @"word".mutableCopy;</span><br><span class="line">NSLog(@"\n oldName:%@ \n newName:%@", oldname, newname);</span><br><span class="line"> </span><br><span class="line">&gt; oldName:hello </span><br><span class="line">&gt; newName:word</span><br></pre></td></tr></tbody></table></figure>
<p>我们使用了引用类型的 NSMutableString，但是 newname 并没有引用复制 oldname，仅仅是指针地址复制了 oldname。这样导致了 newname 并不是 oldname 的别名 (alias)。<br>如果 newname 是 oldname 的别名，那么对 newname 的所有 all 操作，都会同步到 oldname。<br>这里，newname 如果改变了对象数据是可以同步到 oldname，但是却不能改变 oldname 变量的值（oldname 的存储值，即 “hello” 的指针地址）。<br>所以，这里的 NSMutableString 虽然是引用类型，却具有值语义。</p>
<p>因为编程语言概念上的模糊，下面首先介绍 struct 和值类型的关系。<br>然后重点说明值类型和引用类型的区别，这是重点，直接解释了 struct 和 class 的根本区别。<br>最后加一点小彩蛋，介绍 Swift 里面 struct 特性。</p>
<span id="more"></span>

<h3 id="0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？"><a href="#0X00-struct是什么？好像在哪里见过！struct和值类型是什么关系？" class="headerlink" title="0X00 struct是什么？好像在哪里见过！struct和值类型是什么关系？"></a>0X00 struct 是什么？好像在哪里见过！struct 和值类型是什么关系？</h3><p>好久好久之前，是没有 class 什么事的。那时候 C 语言活跃于各种应用场景，在上层抽象了汇编的实现，C 语言可以用于嵌入式、服务器、驱动等。为什么没有 class 什么事情？class 是类，是 OOP（面向对象编程 / 对象导向编程）的专属。而 C 语言是过程式语言，没有对象概念，也就没有 class 什么事情。<br>那时候，都用结构体，也就是 struct。如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// C语言版本</span><br><span class="line">// 人员结构体，具有姓名和年龄</span><br><span class="line">struct Person {</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>那时候，这些数据都叫做<strong>值类型</strong>，而 struct 就是值类型的。值类型是<strong>变量直接包含值</strong>统称，其他的还有基础数据类型，如 Int，long，char，bool，以及自定义 struct（如上面的 Person）。<br>后面大家就知道了，出现了 C++/Java/C# 等 OOP 语言，class 开始活跃于千万家。更甚之，在某些语言上，值类型已经被淡化了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Objective-C版本 .h</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line">@property(nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure>
<p>以上为 OC 的版本，我们会这么描述它：我们创建了一个 Person 类。他具有名称属性和年龄属性。<br>而且，我们也确定，如果我们新建一个 Person 对象，如 <code>Person *p = Person.new;</code>，那么这个对象一定存放在堆内存。那我们为什么不能把对象创建在栈内存呢？<br>我们可以知道，上面 OC 创建的是 Class，对象存在于堆中。那我们可不可以把对象放在栈上？至少在 Objective-C 开发过程中，肯定不会想到这个，因为 struct / 结构体 / 值类型被淡化了。（Java 也是一样，号称纯 OOP 语言）<br>其实我们可以创建栈上的数据的，如局部变量中的 Int、long 等，都是在栈上的。说一个少见的，CGRect、CGSize 也是在栈上的。源码实现如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* Points. */</span><br><span class="line">struct</span><br><span class="line">CGPoint {</span><br><span class="line">    CGFloat x;</span><br><span class="line">    CGFloat y;</span><br><span class="line">};</span><br><span class="line">typedef struct CG_BOXABLE CGPoint CGPoint;</span><br><span class="line"></span><br><span class="line">/* Sizes. */</span><br><span class="line"></span><br><span class="line">struct CGSize {</span><br><span class="line">    CGFloat width;</span><br><span class="line">    CGFloat height;</span><br><span class="line">};</span><br><span class="line">typedef struct CG_BOXABLE CGSize CGSize;</span><br><span class="line"></span><br><span class="line">/* Rectangles. */</span><br><span class="line"></span><br><span class="line">struct CGRect {</span><br><span class="line">    CGPoint origin;</span><br><span class="line">    CGSize size;</span><br><span class="line">};</span><br><span class="line">typedef struct CG_BOXABLE CGRect CGRect;</span><br></pre></td></tr></tbody></table></figure>
<p>其实 OC 中使用的 CGRect 等，也就是 struct 值类型数据。只是我们很少顾及值类型，虽然一直用，但是感知不到他们的存在。<br>直到有一天，Swift 也成了苹果开发的官方语言，引入了 struct，一大堆开发人员开始迷惑，发生了什么事？我该怎么办？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person {</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Swift class版本</span><br><span class="line">class Person {</span><br><span class="line">	var name: String</span><br><span class="line">	var age: UInt8</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同样的 Person，一个是 struct，一个是 class。一个复制的时候是全部数据复制，一个复制的时候是指针复制。一个有可能存放在栈上，一个只能存放在堆上。<br>放心了很多，原来 struct 和 Int、BOOL 等是一样的。他们本身不可以改变，只能被复制。struct 拥有和 Int 一样的外观。<br>等等，Swift 的 struct 可以引入方法，可以实现构造器，甚至可以通过 mutating 来改变自己。俨然已经上升可以和 class 平起平坐了（其实没有高低之分）。这怎么和 Int 又不太一样了？struct 到底是啥？</p>
<p>其实 struct 一直都没有消失。它一直在我们周边。仅仅是因为我们在个别面向对象语言的冲击下，淡化了值类型。<br>而现在，在 Swift 中，我们必须捡起来，因为值类型在 Swift 中不可或缺了。甚至 Swift 里面的 Int,String 等，都是通过 struct 直接实现的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// A signed integer value type.</span><br><span class="line">///</span><br><span class="line">/// On 32-bit platforms, `Int` is the same size as `Int32`, and</span><br><span class="line">/// on 64-bit platforms, `Int` is the same size as `Int64`.</span><br><span class="line">public struct Int : FixedWidthInteger, SignedInteger {</span><br><span class="line"></span><br><span class="line">    /// A type that represents an integer literal.</span><br><span class="line">    public typealias IntegerLiteralType = Int</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>相比之下，C++ 一直存在值类型，而且 C++ 里面的自定义的 struct 还可以继承和多态，完全面向对象化了。</p>
<h3 id="0X01-值类型和引用类型的内存差异"><a href="#0X01-值类型和引用类型的内存差异" class="headerlink" title="0X01 值类型和引用类型的内存差异"></a>0X01 值类型和引用类型的内存差异</h3><p>值类型和引用类型，从语法上还是毕竟容易理解的。如果牵涉到语义，就比较复杂，因为上面说到的，引用类型就牵涉到了值语义。<br>我们先从语法上来理解值类型和引用类型的内存差异。</p>
<h4 id="引用类型内存图"><a href="#引用类型内存图" class="headerlink" title="引用类型内存图"></a>引用类型内存图</h4><p>首先，class 是引用类型，一定是存放在堆内存上的。如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Person {</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: UInt8?</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = "Robot"</span><br><span class="line"> </span><br><span class="line">&gt; person.name:Robot</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></tbody></table></figure>
<p>那么我们定义一个 Person 对象时候的内存分布如下图：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061808341.png" width="50%"><br>person 这个引用变量，我们使用的时候，可能存储在栈中的（也可能在堆中，但不是重点）。但是其指向的对象，却一定是在堆中的。</p>
<blockquote>
<p>这里我们有两个名词认知不要弄混了，一个是 person 变量，一个是 person 对象。变量只是符号，编译的时候存储于符号表中的一个标记，对象才是我们使用的数据实体，变量用于找到对象。someOne 也是同理。下文中的变量和对象都是同理，后面不再做强调。</p>
</blockquote>
<p>上面操作完成后，person 和 someOne 的 name 都变成 Robot 了，这是合情合理的，我们都司空见惯了，不做多描述。</p>
<h4 id="值类型内存图"><a href="#值类型内存图" class="headerlink" title="值类型内存图"></a>值类型内存图</h4><p>下面看看值类型，</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = "Robot"</span><br><span class="line"></span><br><span class="line">&gt; person.name:Hello</span><br><span class="line">&gt; someOne.name:Robot</span><br></pre></td></tr></tbody></table></figure>
<p>内存分布如下图：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061809607.png" width="50%"><br>我们可以发现，值类型相比引用类型，person 和 someOne 这两个值变量，<strong>指向</strong>特征不那么明显了，更多的是复制。我们的 someOne 并没有指向 person，而是把 person 的数据完全复制了一份成为自己的。<br>更重要的，person 和 someOne 存储的，<strong>不再是对象的指针，而是真真实实的数据了</strong>。其实对象依旧还是对象，变量依旧是变量，如上面说的那样。但是，<strong>值变量，直接包含数据 (值类型的定义) <strong>了，不再通过指针指向数据了。<br>当然，我们从图上看到的，值对象是在栈里面。当然值对象也会在堆里面，场景不一样，存储位置也会不一样。但是和引用对象不同的一点，</strong>值对象是可以存储在栈里面的</strong>。</p>
<blockquote>
<p>我们经常使用的 Int 等，其实很多时候都是存储在栈里面的。上面 Person 引用类，其实也有 age 属性，这个 age 属性就是值对象存储在堆上，因为 person 对象是在堆上的。后面说到 struct 和 class 联动内嵌的时候，会详细说明</p>
</blockquote>
<h4 id="值类型和引用类型内存比较"><a href="#值类型和引用类型内存比较" class="headerlink" title="值类型和引用类型内存比较"></a>值类型和引用类型内存比较</h4><p>显而易见，内存方式的不同，带来的优缺点也是迥异的。<br>最直接的，栈肯定是比堆快的。下面我们默认<strong>值对象存储在栈中，引用对象存储在堆中</strong>进行分析。<br><strong>一来</strong>，值类型通过值变量直接定位数据，而引用类型需要通过引用变量的指针间接获取，在寻址方面就会出现时间劣势。<br><strong>再者</strong>，栈通过 CPU 提供的指令寄存器操作数据，而堆通过操作系统支持。堆空间由程序员自行控制，包括垃圾回收等，CPU 不会干预过多。<br><strong>其次</strong>，我们在栈上分配内存，是直接分配。而对于引用类型，只在栈上分配变量地址，对象需要另外分配堆内存空间。（可能会出现这种情况，需要 100 个对象，栈类型会在栈内存中直接分配完毕，而引用类型会在栈上一次性分配 100 个变量内存，然后在堆中需要进行 100 次对象内存分配。）<br><strong>而且</strong>，由于堆内存是空间不连续性的（操作系统分配堆内存池供开发使用，如果一个对象销毁了，就会产生内存碎片），不连续堆空间会违背局部性原理，会增加高速缓存错失的几率（命中不了）。堆空间的高速缓存指的是二级缓存，而栈是依据 “LIFO” 的存储机制，不会出现内存碎片，天然增加了一级缓存的命中率。<br><strong>特别</strong>，各种语言都会着重优化值类型，以达到更快的速度。毕竟栈处理速度的快慢，直接影响到程序的快慢。因为我们的代码运行根本依靠函数，而函数就是在栈中执行，如 main 函数和自定义函数。所以才会加入寄存器这样的快速单元，而堆里的数据，是可以通过异步来完成存储的。<br>因为值对象也是会存储在堆中，所以我们可以这样说：<strong>值类型有可能利用栈的优势，进一步提高程序的性能</strong>。</p>
<p>内存比较上，相比来说，值类型完胜引用类型。<br>引用类型相应的优点，<br>一来，发生在拷贝的过程中。值类型拷贝是完全拷贝，所有数据都会拷贝一遍，而引用类型，拷贝的仅仅是指针，从而提交效率。<br>二来，栈内存空间有有限的，相比堆内存空间，简直太小来，如著名的网站 “Stack Overflow” 的名字一样，动不动就会栈溢出。而堆内存，就是普通点的服务器，4G 容量不是问题的，高级点的服务器都是几十几百 G 容量。<br>我们可以看出，栈和堆相比，强于速度，弱于空间。虽然速度完胜，但除了空间，还有其他方面，引用类型却又是完胜值类型的。从 Java，Objective-C 这些语言上不难看出，引用类型的确是完胜值类型的。下面我们一点点来分析他们之间的不同和场景应用。</p>
<h3 id="0X02-值类型和引用类型的相等性差异"><a href="#0X02-值类型和引用类型的相等性差异" class="headerlink" title="0X02 值类型和引用类型的相等性差异"></a>0X02 值类型和引用类型的相等性差异</h3><h4 id="值类型相等性比较"><a href="#值类型相等性比较" class="headerlink" title="值类型相等性比较"></a>值类型相等性比较</h4><p>我们回顾一些最基础的值类型 Int 的相等性比较。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 100</span><br><span class="line">var num2 = 100</span><br><span class="line">assert(num1 == num2)</span><br><span class="line">var num3 = 200</span><br><span class="line">assert(num1 != num3)</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码编译运行，断言是可以通过的。值类型的比较，特别简单，就是比较数据是否一样。<br>因为值类型，不管存储在哪里，不变的一点是，值变量直接包含值对象。我们自定义一个值类型来看一下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person: Equatable {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = "Hello"</span><br><span class="line">// someOne.name = "Robot"</span><br><span class="line"> </span><br><span class="line">assert(person == someOne)</span><br><span class="line">// assert(person != someOne)</span><br></pre></td></tr></tbody></table></figure>
<p>它们的内存图如下：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061810033.png" width="50%"><br>当两个值对象的 name 都是 Hello 的时候，两个值对象是相等的。如果 someOne 的 name 变成 Robot，两个值对象就是不想等的。（如果我们把注释的代码打开，相应注释位置上一行代码删除，会发现两个断言都是可以通过的。）<br>值类型的相等性比较真的非常简单，就是匹配字节码是否一致。只要值对象的所有字节码是一致的，那两个值对象就是相等的。字节码从哪里来？Hello 和 Robot，计算机不认识的，他们都会变成对应的码值然后转化成二进制存储内存中。所以值类型相等性判断就是查看二进制是否一样。</p>
<h4 id="引用类型相等性比较"><a href="#引用类型相等性比较" class="headerlink" title="引用类型相等性比较"></a>引用类型相等性比较</h4><p>因为引用变量存储的是引用对象的内存地址。同样一个对象，可能有两个引用变量存储着其地址。<br>所以引用类型的比较，有两个方面，一个是比较存储的内存地址是否一致，另一个是比较内存地址对应的数据是否一致。<br>因为字符串在 Swift 里面是值类型的，我们用 Objective-C 里面的 NSString 来分析。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 = [NSString stringWithFormat:@"%@", @"Hello"];</span><br><span class="line">NSString *str2 = @"Hello";</span><br><span class="line"></span><br><span class="line">assert(str1 == str2);   // ERROR</span><br><span class="line">assert([str1 isEqualToString:str2]); // OK</span><br></pre></td></tr></tbody></table></figure>
<p>相应的内存图如下：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061811891.png" width="50%"><br>因为 Objective-C 对于字符串的生成比较考究（Objective-C 里面，字符串根据创建的形式不同和存储中英文的不同，有常量区、栈区、堆区不同表现形式），我们用上面方式建立两个不同地址的 Hello 字符串。其中比较相等性，一个是通过 **==<strong>，一个是通过</strong> equal**。<br>引用类型的相等性比较，直接通过值类型的 == 比较的化，比较的是内存地址，显然 str1 和 str2，他们的内存地址不可能一样，所以他们并不相等。<br>而通过 equal 来比较，就变成了上面的值类型的字节码比较，Hello 的二进制存储都是一样的，他们就相等了。</p>
<h3 id="0X03-值类型和引用类型在花式传参过程中的异同"><a href="#0X03-值类型和引用类型在花式传参过程中的异同" class="headerlink" title="0X03 值类型和引用类型在花式传参过程中的异同"></a>0X03 值类型和引用类型在花式传参过程中的异同</h3><blockquote>
<p>如果不能把值传参、地址传参和引用传参与类对象联系起来，也无法理解不同传参下对象的使用和 struct、class 的应用场景。</p>
</blockquote>
<p>为什么三种传参方式对 struct 和 class 的理解如此重要？其实他们本不重要，只是附带品。但是因为很多很多人对他们认知是错误的，所以才变得重要起来。<br>毕竟，错误的理论，总不能推导出来正确的知识。<br>首先，我们需要确定一个知识点，<strong>值传参</strong>、<strong>引用传参</strong>、<strong>地址传参</strong>和<strong>值类型</strong>、<strong>引用类型</strong>相比，虽然也有<strong>值</strong>和<strong>引用</strong>的区分，但他们不一一对应的关系，即不是值类型对应值传参。<br>值类型和引用类型是数据存在的方式，三种传参方式，是数据传递的方式。他们是对数据两个层面的操作控制。<br>所以，我们总共有 6 种情况需要分析：值类型下的值传参、引用传参、地址传参，引用类型下的值传参、引用传参、地址传参。<br>说明：因为引用传参很多语言默认都没有实现，如 Java、Objective-C、Swift 等等，所以需要通过 C++ 模拟。</p>
<h4 id="值类型下的值传参、引用传参、地址传参"><a href="#值类型下的值传参、引用传参、地址传参" class="headerlink" title="值类型下的值传参、引用传参、地址传参"></a>值类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的值传参</span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person: Equatable {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person</span><br><span class="line">someOne.name = "Robot"</span><br><span class="line">someOne = Person(name: "SomeOne", age: 18)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的地址传参</span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">func change(someOne: inout Person) {</span><br><span class="line">    someOne.name = "Robot"</span><br><span class="line">    someOne = Person(name: "SomeOne", age: 18)</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">change(someOne: &amp;person)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的引用传参</span><br><span class="line">// C++ 版本</span><br><span class="line">void change(int &amp; param2){</span><br><span class="line">    param2++;</span><br><span class="line">    param2 = 100;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">int param1 = 20;</span><br><span class="line">change(param1);</span><br></pre></td></tr></tbody></table></figure>
<p>上面的内存分布如图：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061811789.png" width="50%"></p>
<p>我们分析一下值类型下的三种传参，</p>
<ol>
<li>值传参，就是行参对象原封不动的获取了实参对象的<strong>数据拷贝</strong>。两个对象之间不再有任何关联，对行参对象的内部修改 (someOne.name = “Robot”) 和自身修改 (someOne = Person (name: “SomeOne”, age: 18))，都不会更改另一个对象的任何数据。如上图所示，person 对象没有任何修改。</li>
<li>地址传参，就是行参对象原封不动的获取了实参对象的<strong>地址拷贝</strong>。所以行参实际存储的是实参的内存地址拷贝。那么通过内存地址对数据的内部修改 (someOne.name = “Robot”) 都会影响到原对象，毕竟对象只有一个。但是行参自身修改 (someOne = Person (name: “SomeOne”, age: 18))，却不会影响到原对象，因为行参是实参的地址拷贝，自身数据的改变就是改变了拷贝的那份内存地址，不会影响到实参。<strong>所以地址传参，本质还是值传参，因为拷贝了实参的内存地址（而非整个对象数据）</strong>。而通过内存地址修改原数据，这是一种途径，和传参无关，因为内存地址本身就是用来获取和修改数据的。</li>
<li>引用传参，分析起来其实最简单的。那就是，行参仅仅是实参的一个别名 (alias)。行参存储的依旧是实参的内存地址拷贝，但是对行参所有的操作，都会通过<strong>间接寻址</strong>的方式直接操作实参。注意，是所有操作，因为行参仅仅是实参的别名。所以我们看到，引用传参里面，行参不仅可以修改原对象数据，还可以更换原对象。(这个更换原对象，有两种方式，上图中是其中一种，即在原对象内部修改数据，没有创建新对象。还有一种方式是创建一个全新的对象，然后实参指向新对象，是以新换旧的思想。但是原理都不变，都是行参操作实参直接改变数据。)</li>
</ol>
<p>通过上面值类型的三种传参，大家可能已经发现，在 Objective-C、Java、Swift 里面进行值类型的实参行参赋值的时候，其实<strong>都只是值传参和地址传参，并没有引用传参</strong>。只有个别语言如 C++ 里面才支持引用传参。<br>上面说明的是值类型，那么引用类型的三种传参是否会有一些不同呢？</p>
<h4 id="引用类型下的值传参、引用传参、地址传参"><a href="#引用类型下的值传参、引用传参、地址传参" class="headerlink" title="引用类型下的值传参、引用传参、地址传参"></a>引用类型下的值传参、引用传参、地址传参</h4><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型的值传参</span><br><span class="line">// Swift class版本</span><br><span class="line">class Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) {</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; Person {</span><br><span class="line">        return Person(name: name, age: age)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person.copy();</span><br><span class="line">person.name = "Robot"</span><br><span class="line">someOne.name = "SomeOne"</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型下的地址传参</span><br><span class="line">// Swift class版本</span><br><span class="line">class Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    init(name: String, age: UInt8) {</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br><span class="line"> </span><br><span class="line">var someOne = person;</span><br><span class="line">person.name = "Robot"</span><br><span class="line"> </span><br><span class="line">someOne = Person(name: "SomeOne", age: 18)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 引用类型下的引用传参</span><br><span class="line">// C++ 版本</span><br><span class="line">class Person {</span><br><span class="line">public:</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    Person(char *temp, int flag);</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line">Person::Person(char *temp, int flag) {</span><br><span class="line">    name = new char[strlen(temp) + 1];</span><br><span class="line">    strcpy(name, temp);</span><br><span class="line">    age = flag;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">void change(Person &amp;someOne) {</span><br><span class="line">    someOne.name = "Robot";</span><br><span class="line">    someOne = Person("SomeOne", 18);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) {</span><br><span class="line"> </span><br><span class="line">    Person person("Hello", 20);</span><br><span class="line">    change(person);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的内存分布如图：<br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061812422.png" width="50%"></p>
<p>我们分析一下引用类型下的三种传参，</p>
<ol>
<li>值传参，因为引用类型不支持值传参，所以我们使用 copy，模拟了值传参。这也是<strong>深拷贝</strong>的实现方式。我们通过自定义 copy 来实现引用类型的值传参。</li>
<li>地址传参，和值类型的地址传参没有区别。</li>
<li>引用传参，和值类型的引用传参没有区别。</li>
</ol>
<p>我们发现，值类型的直接赋值，使用的是值传参。引用类型的直接赋值，使用的是地址传参。而在值类型下的三种传参分析中，我们分析到<strong>地址传参就是特殊的值传参</strong>。<br>所以我们可以得出结论，<strong>值类型和引用类型的直接赋值，都是值传参的形式</strong>。而引用传参，需要语言级别的实现，目前 C++ 有实现，Java、Objective-C、Swift 等语言中皆没有实现。</p>
<h4 id="花式传参总结"><a href="#花式传参总结" class="headerlink" title="花式传参总结"></a>花式传参总结</h4><p>值传参、地址传参、引用传参，是数据赋值过程中的不同表现形式。而地址传参，本质还是值传参。所以我们可以说只有两种传参方式，即值传参和引用传参。<br>而值传参和引用传参，和值类型与引用类型不是一一对应的关系，具体不同是下文说到的语义的不同，即：</p>
<ol>
<li>根据我们使用的场景，我们可以通过将值传参和引用传参作用于值类型对象上。</li>
<li>根据我们使用的场景，我们也可以通过将值传参和引用传参作用于引用类型对象上。</li>
<li>如果我们需要改变实参，则我们需要引用传参。(很多语言不支持)</li>
<li> 如果我们不需要改变实参，则我们需要值传参。如果想进一步改变原对象的部分值，则需要地址传参通过指针来实现。</li>
</ol>
<h3 id="0X04-值语义和引用语义的联动性"><a href="#0X04-值语义和引用语义的联动性" class="headerlink" title="0X04 值语义和引用语义的联动性"></a>0X04 值语义和引用语义的联动性</h3><p>直观来说，值类型语法上是静态的，变量直接包含并操作数据。引用类型语法上是动态的，通过对象的引用操作数据。从值类型和引用类型的内存结构图可以分析出来。<br>所以，我们引申出<strong>值语义</strong>，即数据是静态的，也就是值传参的逻辑，是数据拷贝，是一份全新的数据。<br>我们也引申出<strong>引用语义</strong>，即数据是动态的，也就是引用传参的逻辑，数据可以通过别名操作，数据本身没有进行任何复制。<br>所以我们可以这样理解，值类型默认应该是值语义的，引用类型默认应该是引用语义的。<br>如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 值变量v1与v2互相独立</span><br><span class="line">ValueType v1 = someValue;</span><br><span class="line">ValueType v2 = v1;</span><br><span class="line"></span><br><span class="line">// 引用变量r1与r2互相关联</span><br><span class="line">ReferenceType r1 = someObject;</span><br><span class="line">ReferenceType r2 = r1;</span><br></pre></td></tr></tbody></table></figure>
<p>上面 v1 和 v2 都是值类型 ValueType 的对象，其中 v1 和 v2 没有任何关联，默认的值传参。<br>上面 r1 和 r2 都是引用类型 ReferenceType 的对象，其中 r2 是 r1 的别名，操作 r2 和操作 r1 完全一样。</p>
<p>但是事与愿违，至少引用类型的默认引用传参，就是很多语言所不支持的。我们的 Swift 就没有办法实现引用类型的引用传参。即上面的 r1 和 r2 如果在 Swift 中定义，那么 r2 不是 r1 的别名，仅仅是 r1 存储的 someObject 地址的一份拷贝。</p>
<p>所以，严格按照引申出来的<strong>值语义</strong>和<strong>引用语义</strong>的定义，那么很多语言都没有引用语义了。这显然是片面的，因为我们的地址传参，也可以通过指针操作数据来实现动态性。<br>所以严格的定义如下：<br><strong>值语义的对象是独立的，</strong><br><strong>引用语义的对象却是允许共享的。</strong><br>理解下来，就是：<br>值传参具有值语义，因为值传参后行参实参两个对象完全独立。<br>地址传参和引用传参，具有引用语义，因为行参可以通过指针或者别名（实质还是指针，间接寻址方式）来操作实参对象。</p>
<p>我们在 “花式传参” 中说到有 6 种传参方式，因为值类型对应三种传参，引用类型也对应三种传参。<br>所以我们可以发现：<br><strong>值类型通过地址传参和引用传参，可以实现引用语义。</strong><br><strong>引用类型通过值传参，可以实现值语义。</strong><br><img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061813761.png" width="50%"></p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 值类型的 ValueType具有引用语义(C++)</span><br><span class="line">ValueType v1 = someValue;</span><br><span class="line">ValueType&amp; v2 = v1;             // 方法1：通过引用让v2成为v1的别名</span><br><span class="line">ValueType* v3 = &amp;v1;            // 方法2：通过指针让v3指向v1</span><br><span class="line"> </span><br><span class="line">// 引用类型的ReferenceType具有值语义</span><br><span class="line">ReferenceType r1 = someObject;</span><br><span class="line">ReferenceType r2 = r1.copy();    // r1与r2是两个完全独立的对象</span><br></pre></td></tr></tbody></table></figure>
<p>而相应的语言如 Objective-C 就有很多语义层级的类型处理，将值类型处理成引用语义，将引用类型处理成值语义。如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// int值类型具有引用语义</span><br><span class="line">int i1 = 8;</span><br><span class="line">int *i2 = &amp;i1;</span><br><span class="line">(*i2)++;</span><br><span class="line">NSLog(@"i:%d,ii:%d", i1, *i2);// i1:9,i2:9</span><br><span class="line"> </span><br><span class="line">// NSString引用类型具有值语义</span><br><span class="line">NSString *s1 = @"s1 value";</span><br><span class="line">NSString *s2 = s1;</span><br><span class="line">s2 = @"s2 value";</span><br><span class="line">NSLog(@"s1:%@,s2:%@", s1, s2);// s1:s1 value,s2:s2 value</span><br></pre></td></tr></tbody></table></figure>
<p>所以，<br>语法上的值类型可能是语义上的引用类型，<br>语法上的引用类型可能是语义上的值类型。</p>
<h3 id="0X05-值类型和引用类型的抽象层级差异"><a href="#0X05-值类型和引用类型的抽象层级差异" class="headerlink" title="0X05 值类型和引用类型的抽象层级差异"></a>0X05 值类型和引用类型的抽象层级差异</h3><p>在文章开头提到的值类型和引用类型的内存模型中，已经明确值类型是直接包含数据，而引用类型是通过内存地址间接操作数据。<br>从内存分布上，我们可以模糊的发现：</p>
<ol>
<li><strong>值类型，重在数据，是静态的。</strong>如果一个数据是通过值类型来展示，那么这个数据重在数据的价值。这个数据一定非常重要，而我们可以通过值变量直接获取。</li>
<li><strong>引用类型，重在如何使用，是动态的。</strong>如果一个数据是通过引用类型来展示，那么这个数据重在如何被使用。这个数据当然也重要，但是我们可以通过指针和引用 (别名 / 间接寻址) 变相获取，而指针可以赋值给其他变量，最后可以通过各个变量来获取。</li>
</ol>
<p>我们可以创建各种面向对象的引用类型 (class)，然后实现继承和多态，这是引用类型带来的益处。因为我们可以通过指针和引用轻松的实现多态特征。<br>而对于值类型 (struct)，Swift 文档里直接说明，struct 不允许继承和重载。值类型在编译期间具体类型就已经确定，多态绑定也是不可能，因为其空间大小已经确定，没有空余空间容纳子类型。<br>所以从抽象层级上来观看，引用类型相比值类型，抽象层级更高。</p>
<p>因为值类型在编译期间空间大小和具体类型已经确定，所以值类型完全就是不依赖内存地址的，这也是为什么值变量直接包含值对象的原因，所以值类型是具有<strong>空间无关性</strong>的。而引用类型存储于堆中，必须通过指针进行访问，显然引用类型和空间是强关联的。<br>而且，值类型的数据在值对象生命周期内是固定的，体现了不可变性，具有<strong>时间无关性</strong>。即使通过地址传参和引用传参，我们可以改变值对象的数据，那也是在原来的存储空间中，用新数据覆盖旧数据，使用了旧数据的存储空间而已。引用类型的改变是一种自我更新，对象上发生状态迁移和属性改变。<br>因为值类型的时间无关性和空间无关性，所以值类型天然具有重数据，对象意识淡薄，更多的体现在属性而非实体。比如我们描述一个 Person 的 struct，更多的体现在用 age，sex 等抽象属性来描述 “20”“男” 这样的具体数据（“20”、“男” 本身是具体的，age、sex 属性则是面向对象层级的抽象描述）。<br>而引用类型与值类型相比是对立面的抽象表达，更多的体现一个实体对象。比如我们描述一个 Person 的 class，更多的体现在男人、女人、好人、坏人这样的实体对象。</p>
<p>总结来看，值类型是引用类型的基础，值类型在内存和速度的使用上，拥有更快的速度。引用类型在值类型之上进行了更多的抽象。<br>引用类型依靠间接性和抽象性，相比值类型拥有来更大的灵活性，小方面来说在赋值上通过地址传参和引用传参节省了时间损耗，大方面来说通过间接性和抽象性，直接成为实现多态的必要条件。<br>这也从侧面反映了 class 可以继承和多态，看起来繁荣昌盛，而 struct 则显得不起眼，为居一隅却撑起来整个面向对象大厦。</p>
<h3 id="0X06-struct和class联动内嵌下的认知"><a href="#0X06-struct和class联动内嵌下的认知" class="headerlink" title="0X06 struct和class联动内嵌下的认知"></a>0X06 struct 和 class 联动内嵌下的认知</h3><p>单个分析值类型和引用类型还比较容易理解，如果值类型和引用类型相互嵌套，虽然并不是复杂的逻辑，但如果不画图理解一下，很容易脑回路阻塞。<br>下面通过示例代码和内存图清晰了解一下：</p>
<h4 id="值类型嵌套值类型"><a href="#值类型嵌套值类型" class="headerlink" title="值类型嵌套值类型"></a>值类型嵌套值类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Swift struct版本</span><br><span class="line">struct Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">}</span><br><span class="line">var person = Person(name: "Gongjiang", age: 20)</span><br><span class="line">person.name = "Hello"</span><br></pre></td></tr></tbody></table></figure>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061814818.png" width="50%">

<h4 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog {</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) {</span><br><span class="line">        self.name = name</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Swift struct版本</span><br><span class="line">struct Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    // 引用类型</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">var dog = Dog(name: "Wa")</span><br><span class="line">var person = Person(name: "Gongjiang", age: 20, dog: dog)</span><br><span class="line">person.name = "Hello"</span><br></pre></td></tr></tbody></table></figure>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061814319.png" width="50%">

<h4 id="引用类型嵌套值类型"><a href="#引用类型嵌套值类型" class="headerlink" title="引用类型嵌套值类型"></a>引用类型嵌套值类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog {</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) {</span><br><span class="line">        self.name = name</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">var dog = Dog(name: "Wa")</span><br></pre></td></tr></tbody></table></figure>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061815244.png" width="50%">

<h4 id="引用类型嵌套引用类型"><a href="#引用类型嵌套引用类型" class="headerlink" title="引用类型嵌套引用类型"></a>引用类型嵌套引用类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift class版本</span><br><span class="line">class Dog {</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) {</span><br><span class="line">        self.name = name</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Swift class版本</span><br><span class="line">class Person {</span><br><span class="line">    var name: String</span><br><span class="line">    var age: UInt8</span><br><span class="line">    var dog: Dog    // 引用类型</span><br><span class="line">    init(name: String, age: UInt8, dog: Dog) {</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.dog = dog</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var dog = Dog(name: "Wa")</span><br><span class="line">var person = Person(name: "Gongjiang", age: 20, dog: dog)</span><br><span class="line">person.name = "Hello"</span><br></pre></td></tr></tbody></table></figure>
<img data-src="https://cdn.jsdelivr.net/gh/yigegongjiang/image_space@main/blog_img/202308061815976.png" width="50%">

<h3 id="0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？"><a href="#0X07-Swift中的struct为什么很特别？struct能给我们带来哪些认知？" class="headerlink" title="0X07 Swift中的struct为什么很特别？struct能给我们带来哪些认知？"></a>0X07 Swift 中的 struct 为什么很特别？struct 能给我们带来哪些认知？</h3><p>本身 struct 不是很特别，但是在目前很流行的语言（Objective-C、Java）均不支持自定义 struct 的前提下，Swift 开始支持了。而且 Swift 本身如 String、Int、Bool 等均为 struct。Swift 把已经被很多开发人员忽视的值类型提到了非常高的高度，这就非常值的重视了。</p>
<ol>
<li>值对象本身是比引用对象安全的。通过指针可以直接操作数据，如果代码逻辑比较复杂，那么在一个不起眼的位置，很可能修改了一个共享的重要参数，非常有利于 bug 的滋生和增加 bug 排查复杂度。相比来说，值对象具有空间无关性，代码层面上可以有效的抵制指针带来的负面影响。所以值对象是更安全的。</li>
<li>struct 没有引用计数，本身是自动线程安全的。</li>
<li>在上面<strong>值类型和引用类型的内存差异</strong>中，我们说到，值类型相比引用类型，有速度上的天然优势。</li>
<li>struct 没有继承，相对来说更安全，而且 struct 可以实现协议，可以很好的实现面向协议编程。Swift 是一门多范式编程的语言，其中对于面向协议编程尤其重视。</li>
</ol>
<h3 id="OX08-Swift下String的搅局误区"><a href="#OX08-Swift下String的搅局误区" class="headerlink" title="OX08 Swift下String的搅局误区"></a>OX08 Swift 下 String 的搅局误区</h3><p>在讨论 Swift 的值类型中，多次提到 String 类型是值类型的。我相信很多朋友都疑惑，String 作为值类型是如何实现的。<br>毕竟，下面的代码中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var str = "Hello"</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) { (value) in</span><br><span class="line">    print(value)    // 0x0000000100145060</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">str.append("Hello...Hello") // 有1000个Hello</span><br><span class="line"></span><br><span class="line">withUnsafePointer(to: &amp;str) { (value) in</span><br><span class="line">    print(value)    // 0x0000000100145060</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们定义了一个可变变量 str 为值类型的字符串变量，按照内存图逻辑，在 str 拼接了 1000 个 Hello 后，再怎么说，str 的空间存储也不够了。<br>如果 str 的内存地址变化了，那么就说明 str 不是值类型了（上面我们说过值类型的内存变化）。<br>如果 str 的内存地址没有变，那 str 再怎么也存储不了无限多个字符啊！<br>我们拿 Int 来做对比：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i: Int8 = 10</span><br><span class="line">i = 10000000    // Error</span><br></pre></td></tr></tbody></table></figure>
<p>这里如果对 Int8 值类型的变量赋值过大，首先编译就过不了了，超过 Int8 的存储空间了嘛。<br>值类型的空间大小，在编译时就已经确定，这是毋庸置疑的。<br>那 String 是如何做到的呢？<br>打印一下上面代码中的 str 大小，看看到底是多大：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = "Hello"</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    // 16</span><br><span class="line"></span><br><span class="line">str.append("Hello...Hello") // 有1000个Hello</span><br><span class="line"></span><br><span class="line">print(MemoryLayout.stride(ofValue: str))    // 16</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现，str 的内存大小，没有变化过…<br>这也说明了，String 的确是值类型的，它真的可以存储非常非常多的字符。<br>我在查看了 “<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWppb3Mv">M 了个 J</span>” 大神的博客后，依然无解，因为他把答案公布在了两小时的汇编视频中，而我没有去看。<br>这里把大神的博客放下，希望有心人能去窥探一下。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWppb3MvcC8xMTc5OTEzNi5odG1s">https://www.cnblogs.com/mjios/p/11799136.html</span></p>
<hr>
<p>朋友对我说，抽象是一名程序员核心的能力。很多时候，我越发觉得这句话说的对！</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Follow me by other channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/hai_lv_">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/hai_lv_tg">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="mailto:one.gongjiang@gmail.com">
            <span class="icon">
              <i class="fa fa-envelope"></i>
            </span>

            <span class="label">Email</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag"># 计算机原理</a>
              <a href="/tags/%E5%86%85%E5%AD%98/" rel="tag"># 内存</a>
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Swift/" rel="tag"># Swift</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/creditCard/" rel="prev" title="逃离信用卡和花呗">
                  <i class="fa fa-angle-left"></i> 逃离信用卡和花呗
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/my2019/" rel="next" title="我的 2019">
                  我的 2019 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">Light Mode (Better for light mode to discuss, base github, cannot commen can email me)</a></li>
            <li class="tab"><a href="#comment-utterances">Dark Mode</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments utterances-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class=""></i>
    </span>
    <span class="author" itemprop="copyrightHolder">one.gongjiang艾特gmail.com 所有文章均为原创。我不介意任意形式的转载，但最好不要修改内容。因转载或者修改内容导致的任何问题，我均不负责。如果你真的担心版权，可邮联。评价需要外网，这是枷锁，也是照妖镜。</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.yigegongjiang.com/2019/SwiftStruct/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yigegongjiang","repo":"yigegongjiang_discuss","client_id":"65bebc0a049450012bda","client_secret":"06004e7143dc59f263a8d1bd1893dcf66d6bb7ee","admin_user":"yigegongjiang","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"986980c619b9a362aa8062e811374702"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"yigegongjiang/yigegongjiang_discuss","issue_term":"title","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
